<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Tag: Skadi | 氕氘氚</title>
    <meta name="keywords" content="hexo,theme,otakism,otaku"/>
    <meta name="HandheldFriendly" content="True"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="google-site-verification" content=""/>
    <meta name="baidu-site-verification" content=""/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Open your eyes to see the light in life">
<meta property="og:type" content="website">
<meta property="og:title" content="氕氘氚">
<meta property="og:url" content="http://example.com/tags/Skadi/index.html">
<meta property="og:site_name" content="氕氘氚">
<meta property="og:description" content="Open your eyes to see the light in life">
<meta property="og:locale">
<meta property="article:author" content="Szczecin">
<meta name="twitter:card" content="summary">
    

    <!-- Favicon -->
    
        <link rel="icon" href="/img/favicon.ico" />
    

    <!-- Font -->
    <link href="https://fonts.googleapis.com/css?family=Inconsolata|Roboto:300,400,700" rel="stylesheet">

    
<link rel="stylesheet" href="/style.css">

    <script>
      function setLoadingBarProgress(num) {
        document.getElementById('loading-bar').style.width = num + "%";
      }
    </script>

    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>

<div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

<script>setLoadingBarProgress(20)</script>

<div id="site-wrapper">

    <header id="header">
    <div id="header-wrapper" class="clearfix">
        <a id="logo" href="/">
            <img src="/img/logo.png"/>
            <span id="site-desc">
                Be A Gorgeous World
            </span>
        </a>
        <button id="site-nav-switch">
            <span class="icon icon-menu"></span>
        </button>
    </div>
</header>
    <script>setLoadingBarProgress(40);</script>

    <main id="main" role="main">
        
  <section class="page-header tag">
    <h1>- <span>Skadi</span> -</h1>
  </section>






<section class="post-list">
  
    <article class="post ">

    
        <h2 class="title">
            <a href="/2022/08/09/How-To-Hunt/">
                SRC 发掘之旅
            </a>
        </h2>
    
    <time>
        Aug 9, 2022
    </time>
    <section class="content">
        <h1><span id="斯卡蒂的赏金猎人之旅src">斯卡蒂的赏金猎人之旅（SRC）</span></h1><blockquote>
<p>本文实际上是在 <a target="_blank" rel="noopener" href="https://kathan19.gitbook.io/howtohunt/">HowToHunt</a> 的基础上结合自己在安全学习工作的经验，算是译写的一份 SRC 初步指南，有时间学习 SRC 发掘应该就会更新（大概？）。</p>
</blockquote>
<ul>
<li><a href="#%E6%96%AF%E5%8D%A1%E8%92%82%E7%9A%84%E8%B5%8F%E9%87%91%E7%8C%8E%E4%BA%BA%E4%B9%8B%E6%97%85src">斯卡蒂的赏金猎人之旅（SRC）</a><ul>
<li><a href="#%E5%A6%82%E4%BD%95%E5%8F%91%E7%8E%B0%E7%8C%8E%E7%89%A9how-to-hunt">如何发现猎物？（How To Hunt?）</a><ul>
<li><a href="#%E8%B4%A6%E6%88%B7%E6%8E%A7%E5%88%B6account-takeovers-methods">账户控制（account takeovers methods）</a></li>
<li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BA%A7-dosapplication-level-dos-methods">应用程序级 DoS（Application Level DoS Methods）</a></li>
<li><a href="#%E7%BB%95%E8%BF%87%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81authentication-bypass">绕过身份验证（Authentication Bypass）</a></li>
<li><a href="#%E4%BA%8C%E6%AC%A1%E8%AE%A4%E8%AF%812fa%E7%BB%95%E8%BF%87">二次认证（2FA）绕过</a></li>
<li><a href="#%E4%B8%80%E6%AC%A1%E6%80%A7%E5%AF%86%E7%A0%81%E5%8A%A8%E6%80%81%E5%AF%86%E7%A0%81otp%E7%BB%95%E8%BF%87">一次性密码&#x2F;动态密码（OTP）绕过</a></li>
<li><a href="#%E5%88%A9%E7%94%A8%E6%96%AD%E5%BC%80%E9%93%BE%E6%8E%A5%E5%8A%AB%E6%8C%81broken-link-hijacking">利用断开链接劫持（Broken-Link Hijacking）</a></li>
<li><a href="#%E7%94%B1%E4%BC%9A%E8%AF%9D%E8%A1%8D%E7%94%9F%E7%9A%84%E9%97%AE%E9%A2%98session-based-bugs">由会话衍生的问题（Session Based Bugs）</a></li>
<li><a href="#%E5%86%85%E5%AE%B9%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9Fcms">内容管理系统（CMS）</a></li>
<li><a href="#%E8%B7%A8%E5%9F%9F%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%ABcors">跨域资源共享（CORS）</a></li>
<li><a href="#csrf">CSRF</a></li>
<li><a href="#%E5%AF%BB%E6%89%BE-cvefinding-cves">寻找 CVE（finding CVES）</a></li>
<li><a href="#web-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E6%A3%80%E6%B5%8B%E6%B8%85%E5%8D%95">Web 应用程序渗透测试检测清单</a></li>
<li><a href="#%E7%BD%91%E9%A1%B5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1web-page-source-code-review">网页代码审计（Web Page Source Code Review）</a></li>
<li><a href="#%E6%B2%A1%E6%9C%89%E5%89%A5%E7%A6%BB%E7%9A%84-exif-%E5%9C%B0%E7%90%86%E6%95%B0%E6%8D%AEexif-geo-data-not-stripped">没有剥离的 EXIF 地理数据（EXIF Geo Data Not Stripped）</a></li>
<li><a href="#%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%BB%95%E8%BF%87file-upload-bypass">文件上传绕过（File Upload Bypass）</a></li>
<li><a href="#%E6%BA%AF%E6%BA%90find-origin">溯源（Find Origin）</a></li>
<li><a href="#graphql">GraphQL</a></li>
<li><a href="#http-%E8%B5%B0%E7%A7%81%E6%BC%8F%E6%B4%9Ehttp_desync-attack">HTTP 走私漏洞（HTTP_Desync Attack）</a></li>
<li><a href="#host-header-attack">Host-Header Attack</a></li>
<li><a href="#html-injection">HTML-Injection</a></li>
<li><a href="#idor">IDOR</a></li>
<li><a href="#jwt">JWT</a></li>
<li><a href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD">未完待续</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2><span id="如何发现猎物how-to-hunt">如何发现猎物？（How To Hunt?）</span></h2><h3><span id="账户控制account-takeovers-methods">账户控制（account takeovers methods）</span></h3><h4><span id="xss-cookie-劫持">XSS cookie 劫持</span></h4><blockquote>
<ol>
<li>在身份验证与会话管理过程中尝试进行劫持；</li>
<li>利用 XSS 等方法尝试去窃取 cookie，从而达到控制账户的目的。</li>
</ol>
</blockquote>
<h4><span id="弱密码与登录次数">弱密码与登录次数</span></h4><blockquote>
<ol>
<li>如果一个登录页没有对密码复杂度进行严格要求，或可以尝试弱密码与初始&#x2F;管理账户登录（admin&#x2F;password）；</li>
<li>如果一个登录页没有对一定时间内的登录次数进行限制，可以尝试初步爆破以致SQL注入。</li>
</ol>
</blockquote>
<h4><span id="窃取重置密码凭证token">窃取重置密码凭证（token）</span></h4><blockquote>
<ol>
<li>对可疑站点进行账户密码修改的操作；</li>
<li>利用 BurpSuite 拦截修改请求，并修改包 header 中的 host 值，如：</li>
</ol>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host: target.com</span><br><span class="line">Host: attacker.com</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以尝试在不修改 host的情况下在 header 中加入一些字段：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X-Forwarded-Host: attacker.com</span><br><span class="line">Referrer: https://attacker.com</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="3">
<li>放行发送这个包，如果你在 attacker.com 接下来的 log 中发现了请求，说明你已经成功窃取了这个 token。</li>
</ol>
<p>详见<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/host-header/exploiting/password-reset-poisoning">Password reset poisoning</a></p>
</blockquote>
<h4><span id="尝试-csrf">尝试 CSRF</span></h4><blockquote>
<ol>
<li>修改密码处</li>
<li>修改邮箱处</li>
<li>修改账号安全问题处</li>
</ol>
</blockquote>
<h4><span id="响应包令牌泄露">响应包令牌泄露</span></h4><blockquote>
<p>在注册页或密码重置页：</p>
<ol>
<li>拦截提交的请求包；</li>
<li>Proxy - Intercept - 右键 - 拦截执行（Do intercept） - 此请求的响应（Response to this request），即拦截 response；</li>
<li>放行 request，查看 response 中是否有任何链接、凭证（token）或 一次性密码&#x2F;动态密码（OTP）。</li>
</ol>
</blockquote>
<h3><span id="应用程序级-dosapplication-level-dos-methods">应用程序级 DoS（Application Level DoS Methods）</span></h3><h4><span id="邮件退回攻击">邮件退回攻击</span></h4><blockquote>
<ol>
<li>查看应用程序是否具有群发功能；</li>
<li>伪装需要攻击的邮箱地址作为发件人（如小公司自建企业邮箱）；</li>
<li>向无效的电子邮件账户群发大量邮件；</li>
<li>查看电子邮件服务供应商的退信限制上限；</li>
<li>达到这个退信限制后，被伪造的发件人公司将在一定时间内无法再次发送邮件。</li>
</ol>
<p>推荐先用<a target="_blank" rel="noopener" href="https://github.com/domainaware/checkdmarc">checkdmarc</a>测一下有没有 SPF 等策略，有的话不同邮箱域名间伪造很可能被拦截，当然也看技术手法，我之后也应该会更新一篇详细介绍邮件伪造的<del>（咕咕咕）</del>。</p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://infosecwriteups.com/an-unexpected-bounty-email-bounce-issues-b9f24a35eb68">An Unexpected Bounty — Email Bounce Issues</a></li>
</ul>
</blockquote>
<h4><span id="长密码拒绝服务">长密码拒绝服务</span></h4><blockquote>
<p>密码明文理应被哈希加盐后存储在数据库中，如果没有对密码长度进行限制，那么过长的密码在进行哈希运算时就可能消耗大量的资源。</p>
<ul>
<li>测试方式：</li>
</ul>
<ol>
<li>用长度150-200字的密码测试是否有长度限制；</li>
<li>如果没有，换更长的密码测试，关注一下页面响应的时间；</li>
<li>甚至可以看看会不会崩溃。</li>
</ol>
<ul>
<li>测试点：</li>
</ul>
<ol>
<li>很多页面在注册时限制了密码长度，但是在忘记密码和修改密码的地方遗漏了这个限制。</li>
</ol>
<p>我应该也有相关的 Exploit 文章记录。</p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://www.acunetix.com/vulnerabilities/web/long-password-denial-of-service/">Long password denial of service</a><br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/738569">No length on password</a></li>
</ul>
</blockquote>
<h4><span id="长字符拒绝服务">长字符拒绝服务</span></h4><blockquote>
<p>当使用一些过长的字符串时，服务器可能无法处理，在一定时间内造成拒绝服务。</p>
<ul>
<li>测试点：</li>
</ul>
<ol>
<li>尝试在用户名或网路地址，甚至文件与图片名中使用约1000字符的字串；</li>
<li>用 B 账户搜索 A 账户，其中 A 账户为长字串。<br>看看是否一致处于搜寻状态<br>或者应用崩溃，返回 500 状态码</li>
</ol>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://shahjerry33.medium.com/long-string-dos-6ba8ceab3aa0">Long String DoS</a><br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/764434">profile-picture name parameter with large value lead to DoS for other users and programs on the platform</a></li>
</ul>
</blockquote>
<h4><span id="试试这个密码">试试这个密码</span></h4><blockquote>
<p>实际上并不建议使用超过 5000 个字符的密码<br>但这里有一个<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/KathanP19/HowToHunt/master/Application_Level_DoS/Password.txt">密码本</a></p>
</blockquote>
<h4><span id="对受害者的永久拒绝服务">对受害者的永久拒绝服务</span></h4><blockquote>
<p>这不仅是从应用角度的 DoS，而且可能是对受害者永久的 DoS。在某些网站中，用户用错误的登录凭据登录后，在一定时间内会被登录阻止，我们把这个功能视为 Bug :D。</p>
<ul>
<li>测试方式：</li>
</ul>
<ol>
<li>到某个网站的登录页面（如 example.com）；</li>
<li>现在输入有效的电子邮件账户和错误的密码；</li>
<li>多登录几次（至少 10 - 20 次），可以用 BurpSuite 进行重发（这里要关注一个验证码问题，这个每次要输入，有时候可能也做了加密处理）；</li>
<li>如果账号被阻止登录，且时长越来越长，超过 30 分钟，可以视为存在漏洞。</li>
</ol>
<ul>
<li>需要注意：</li>
</ul>
<ol>
<li>确保登录期间没有验证码，因为我们不能使用任何自动化工具来循环请求；</li>
<li>确保旧的登录会话在被阻止登录后已经过期。</li>
</ol>
<p>反馈此漏洞时可以说能够通过时间间隔循环此登录请求来阻止某用户正常登录。</p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=5drIMXCQuNw">Commonly Misunderstood Bugs: DDoS &amp; DOS</a></li>
</ul>
</blockquote>
<h3><span id="绕过身份验证authentication-bypass">绕过身份验证（Authentication Bypass）</span></h3><blockquote>
<p>讲道理，这里的绕过身份认证更多的是在知道密码的情况下绕过二次认证，要知道用户密码为前提有点没太大意义，无法扩散危害，只能说机制有漏洞可能被劫持利用。</p>
</blockquote>
<h3><span id="二次认证2fa绕过">二次认证（2FA）绕过</span></h3><h4><span id="修改响应">修改响应</span></h4><blockquote>
<p>如果在 2FA 认证的响应包中表示认证状态的布尔值“success”为“false”，改成“true”试一下。</p>
</blockquote>
<h4><span id="修改状态码">修改状态码</span></h4><blockquote>
<p>如果认证响应的状态码为 4xx，改成 200 OK 看看能不能绕过。</p>
</blockquote>
<h4><span id="2fa-码泄露">2FA 码泄露</span></h4><blockquote>
<p>拦截认证响应包，看看是否有 2FA 码直接泄露。</p>
</blockquote>
<h4><span id="分析-js-代码">分析 JS 代码</span></h4><blockquote>
<p>就是看看能不能在认证页的 JS 中直接找到 2FA 码生成的代码，以此推测出 2FA 码。</p>
</blockquote>
<h4><span id="2fa-码重用">2FA 码重用</span></h4><blockquote>
<p>相同的 2FA 码能够被用于下次认证。</p>
</blockquote>
<h4><span id="缺少爆破防护">缺少爆破防护</span></h4><blockquote>
<p>不够长的 2FA 码或许能够被爆破出来。</p>
</blockquote>
<h4><span id="2fa-码缺少完整性验证">2FA 码缺少完整性验证</span></h4><blockquote>
<p>任何用户的 2FA 码都可以通过认证。</p>
</blockquote>
<h4><span id="在禁用-2fa-时进行csrf">在禁用 2FA 时进行CSRF</span></h4><blockquote>
<p>禁用 2FA 时没有进行 CSRF 保护，或者没有再次进行 2FA 验证。</p>
</blockquote>
<h4><span id="密码重置禁用-2fa">密码重置禁用 2FA</span></h4><blockquote>
<p>在密码更改&#x2F;电子邮件更改时禁用 2FA 验证。</p>
</blockquote>
<h4><span id="backup-code-abuse">Backup Code Abuse</span></h4><blockquote>
<p>Bypassing 2FA by abusing the Backup code feature<br>Use the above mentioned techniques to bypass Backup Code to remove&#x2F;reset 2FA restrictions<br>（这里说的是因为备份码被滥用而绕过 2FA 验证，但是我没能理解，看参考文章也是每太理解，就放在这了）</p>
</blockquote>
<h4><span id="在禁用-2fa-页面进行点击劫持">在禁用 2FA 页面进行点击劫持</span></h4><blockquote>
<p>在 2FA 禁用页面设置点击劫持，并利用社会工程学方式诱导禁用 2FA。</p>
</blockquote>
<h4><span id="启用-2fa-无法使之前的会话过期">启用 2FA 无法使之前的会话过期</span></h4><blockquote>
<p>如果存在被劫持的会话且没有设置会话超时，则 2FA 会被绕过。</p>
</blockquote>
<h4><span id="利用-null-或-000000-绕过-2fa">利用 null 或 000000 绕过 2FA</span></h4><blockquote>
<p>在输入 2FA 码时利用 null 或者 000000 尝试进行绕过。</p>
</blockquote>
<blockquote>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://research.nccgroup.com/2021/06/10/testing-two-factor-authentication/">Testing Two-Factor Authentication</a><br><a target="_blank" rel="noopener" href="https://medium.com/@lukeberner/how-i-abused-2fa-to-maintain-persistence-after-a-password-change-google-microsoft-instagram-7e3f455b71a1">How I abused 2FA to maintain persistence after a password change</a></li>
</ul>
</blockquote>
<h3><span id="一次性密码x2f动态密码otp绕过">一次性密码&#x2F;动态密码（OTP）绕过</span></h3><h4><span id="修改响应包在注册用户页x2f登录账户绕过-otp">修改响应包在注册用户页&#x2F;登录账户绕过 OTP</span></h4><blockquote>
<p>方式一：</p>
<ol>
<li>使用手机号码注册账户&#x2F;登录账户并申请 OTP；</li>
<li>输入不正确的 OTP 并在 BurpSuite 中捕获请求；</li>
<li>拦截响应并修改：</li>
</ol>
</blockquote>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">响应如果是：</span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;verificationStatus&quot;</span><span class="punctuation">:</span><span class="keyword">false</span><span class="punctuation">,</span><span class="attr">&quot;mobile&quot;</span><span class="punctuation">:</span><span class="number">9072346577</span><span class="string">&quot;,&quot;</span>profileId<span class="string">&quot;:&quot;</span><span class="number">84673832</span><span class="string">&quot;&#125;</span></span><br><span class="line"><span class="string">修改为：</span></span><br><span class="line"><span class="string">&#123;&quot;</span>verificationStatus<span class="string">&quot;:true,&quot;</span>mobile<span class="string">&quot;:9072346577&quot;</span><span class="punctuation">,</span><span class="attr">&quot;profileId&quot;</span><span class="punctuation">:</span><span class="string">&quot;84673832&quot;</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>转发此响应，看能否登录账户。</p>
<p>方式二：</p>
<ol>
<li>使用任意 2 个手机号码注册 2 个账户，第一个手机输入正确的 OTP；</li>
<li>拦截注册请求，并选择拦截此请求的响应，放行请求；</li>
<li>记录响应包中各参数状态；</li>
<li>另一个手机输入错误的 OTP；</li>
<li>拦截注册请求，并选择拦截此请求的响应，放行请求；</li>
<li>将响应包中各参数修改为正确 OTP 响应状态值，看是否能成功登录。</li>
</ol>
</blockquote>
<h4><span id="使用重发器重复提交表单绕过-otp">使用重发器重复提交表单绕过 OTP</span></h4><blockquote>
<ol>
<li>使用不存在的电话号码创建账户；</li>
<li>利用 BurpSuite 拦截请求，并发送到重发器（Repeater）；</li>
<li>把重发器中请求的电话号码修改为正确的电话号码后，记录 OTP；</li>
<li>回到拦截器（Intercept），放行请求，尝试用之前获得的 OTP 进行注册。</li>
</ol>
</blockquote>
<h4><span id="无速率限制">无速率限制</span></h4><blockquote>
<ol>
<li>创建账户，当应用程序需要你提供 OTP 时，输入错误的 OTP 并拦截此请求；</li>
<li>将此请求发送至重发器（Repeater），选择 OTP 的值，开始在有效范围爆破；</li>
<li>如果没有速率限制，当 OTP 较短复杂度较低，则很容易爆破出来。</li>
</ol>
</blockquote>
<h3><span id="利用断开链接劫持broken-link-hijacking">利用断开链接劫持（Broken-Link Hijacking）</span></h3><blockquote>
<ol>
<li>查找目标站点上的外部链接（如一些指向社交媒体账户的链接或一些外部媒体链接）</li>
<li>检查目标站点公司是否是这个链接的域名所有，没有的话可能被注册用于恶意行为。</li>
</ol>
<p>举例，一个很有名的网站上有调用 JS 文件，存放 JS 文件的链接已经失效，你可以注册，然后在相同的路径放上恶意的 JS 文件。以下工具用于查找断开的链接：<br><a target="_blank" rel="noopener" href="https://github.com/stevenvachon/broken-link-checker">broken-link-checker</a><br><a target="_blank" rel="noopener" href="https://ahrefs.com/broken-link-checker">Online Broken Link Checker</a><br><a target="_blank" rel="noopener" href="https://brokenlinkcheck.com/">Alternative Online Broken Link Checker</a></p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://edoverflow.com/2017/broken-link-hijacking/">Broken Link Hijacking - How expired links can be exploited</a><br><a target="_blank" rel="noopener" href="https://medium.com/@bathinivijaysimhareddy/how-i-takeover-the-companys-linkedin-page-790c9ed2b04d">How I was able to takeover the company’s LinkedIn Page</a></li>
</ul>
</blockquote>
<h3><span id="由会话衍生的问题session-based-bugs">由会话衍生的问题（Session Based Bugs）</span></h3><blockquote>
<p>会话的认证与劫持很多也是建立在你能获取一定的信息上的，也更多是机制上的问题，危害传播更困难。</p>
</blockquote>
<h4><span id="旧会话在密码更改后不会过期">旧会话在密码更改后不会过期</span></h4><blockquote>
<ol>
<li>在目标站点上创建账户；</li>
<li>使用同一账户登录两个浏览器（以 Chrome 和 Firefox 为例）；</li>
<li>在 Chrome 中更改密码，成功更改后，刷新在 Firefox 上的页面，看看是否是登录状态。</li>
</ol>
</blockquote>
<h4><span id="会话劫持预期行为">会话劫持（预期行为）</span></h4><blockquote>
<ol>
<li>创建你的账户并登录；</li>
<li>利用浏览器的 cookie 编辑器插件，copy 所有的目标 cookie，然后登出你的账户；</li>
<li>把所有的目标 cookie 粘贴进 cookie 编辑器；</li>
<li>刷新页面，看看你是否还是登陆状态。</li>
</ol>
<p>Firefox 的插件<a target="_blank" rel="noopener" href="https://addons.mozilla.org/zh-CN/firefox/addon/cookie-editor/#:~:text=%E5%85%B3%E4%BA%8E%E6%AD%A4%E6%89%A9%E5%B1%95%20Cookie-Editor%20is%20designed%20to%20have%20a%20simple,delete%20all%20the%20cookies%20for%20the%20current%20page.">Cookie-Editor</a></p>
</blockquote>
<h4><span id="密码重置令牌不会过期不安全的可配置项">密码重置令牌不会过期（不安全的可配置项）</span></h4><blockquote>
<ol>
<li>在目标网站上创建账户后，登录时请求忘记密码；</li>
<li>不要使用重置密码的链接，而是使用旧密码登录，并将你的电子邮件修改为其他邮箱；</li>
<li>现在使用发送到旧电子邮箱的修改密码链接，看是否可以修改密码，如果是，则存在漏洞。</li>
</ol>
</blockquote>
<h4><span id="安全页的缓存控制服务器安全性配置错误">安全页的缓存控制（服务器安全性配置错误）</span></h4><blockquote>
<ol>
<li>登录应用程序页面，浏览使用功能后注销；</li>
<li>按 Alt + ← ，看是否能回到应用程序登录后的页面。</li>
</ol>
</blockquote>
<h4><span id="绕过电子邮件确认认证">绕过电子邮件确认认证</span></h4><blockquote>
<ol>
<li>在创建用户时，会收到一个邮箱验证链接；</li>
<li>应用程序在没有进行邮箱验证的情况下只会提供较少的权限和功能许可访问；</li>
<li>登录到应用程序，将电子邮件地址更改为电子邮件 B；</li>
<li>会向电子邮件 B 再发送一份验证链接；</li>
<li>将电子邮件更改回创建账户时的电子邮件，看电子邮件是否已验证。</li>
</ol>
<p>这个并不适用于创建账户就要邮箱的情况，感觉要邮箱链接确认账户激活才能登录就会不行，除非注册时候换邮箱再换回去也可以（但理论上再换回去回再发一封确认邮件）；而当用手机号等登录上去了，绑定邮箱有可能都不要验证。</p>
</blockquote>
<h4><span id="电子邮件验证绕过">电子邮件验证绕过</span></h4><blockquote>
<ol>
<li>使用自己的电子邮件地址创建一个账户，创建中会需要电子邮件验证；</li>
<li>不要使用验证链接，而是回到注册页，把电子邮件地址修改为受害者电子邮件地址进行创建；</li>
<li>现在回到自己的电子邮箱，确认链接，看是不是受害者的邮箱被确认。</li>
</ol>
</blockquote>
<h4><span id="旧密码重置令牌在请求新令牌时未过期">旧密码重置令牌在请求新令牌时未过期</span></h4><blockquote>
<ol>
<li>首先，利用有效的电子邮箱创建一个账户，然后注销；</li>
<li>选择忘记密码，请求重置密码链接，但是不要去邮箱使用链接；</li>
<li>再次请求一个密码重置链接；</li>
<li>去电子邮箱使用第一个密码重置链接，看是否能修改密码。</li>
</ol>
</blockquote>
<h4><span id="密码重置令牌在密码更改后未过期">密码重置令牌在密码更改后未过期</span></h4><blockquote>
<ol>
<li>首先，利用有效的电子邮箱创建一个账户，然后注销；</li>
<li>选择忘记密码，请求重置密码链接，使用密码重置链接修改密码后登录；</li>
<li>现在再次使用邮箱中的密码重置链接，看是否还能修改密码。</li>
</ol>
</blockquote>
<h3><span id="内容管理系统cms">内容管理系统（CMS）</span></h3><h4><span id="wordpress">Wordpress</span></h4><blockquote>
<p>基本扫描工具<a target="_blank" rel="noopener" href="https://wpscan.com/">Wpscan</a></p>
</blockquote>
<blockquote>
<p>xmlrpc.php<br>这是 wordpress 上常见的问题之一，可以通过这种错误的配置进行漏洞利用。</p>
<p>检测：</p>
<ul>
<li>访问 site.com&#x2F;xmlrpc.php（有可能有二级路径）</li>
<li>获取有关 POST 请求的错误信息</li>
</ul>
<p>利用：</p>
<ul>
<li>拦截请求包，把请求方式由 GET 改为 POST</li>
<li>列出所有 method</li>
</ul>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">methodCall</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">methodName</span>&gt;</span>system.listMethods<span class="tag">&lt;/<span class="name">methodName</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">params</span>&gt;</span><span class="tag">&lt;/<span class="name">params</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">methodCall</span>&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>检查是否存在<code>pingback.ping</code>方式</li>
<li>试试 DDoS</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;methodCall&gt;</span><br><span class="line">&lt;methodName&gt;pingback.ping&lt;/methodName&gt;</span><br><span class="line">&lt;params&gt;&lt;param&gt;</span><br><span class="line">&lt;value&gt;&lt;string&gt;http://&lt;YOUR SERVER &gt;:&lt;port&gt;&lt;/string&gt;&lt;/value&gt;</span><br><span class="line">&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://&lt;SOME VALID BLOG FROM THE SITE &gt;&lt;/string&gt;</span><br><span class="line">&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>试试 SSRF（仅限内部端口扫描）</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;methodCall&gt;</span><br><span class="line">&lt;methodName&gt;pingback.ping&lt;/methodName&gt;</span><br><span class="line">&lt;params&gt;&lt;param&gt;</span><br><span class="line">&lt;value&gt;&lt;string&gt;http://&lt;YOUR SERVER &gt;:&lt;port&gt;&lt;/string&gt;&lt;/value&gt;</span><br><span class="line">&lt;/param&gt;&lt;param&gt;&lt;value&gt;&lt;string&gt;http://&lt;SOME VALID BLOG FROM THE SITE &gt;&lt;/string&gt;</span><br><span class="line">&lt;/value&gt;&lt;/param&gt;&lt;/params&gt;</span><br><span class="line">&lt;/methodCall&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/nullfil3/xmlrpc-scan">XMLRPC-Scan</a> 可以配合 BurpSuite 一起测试。 </p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://m0chan.github.io/2019/12/17/Bug-Bounty-Cheetsheet.html">Bug Bounty Cheat Sheet</a> 这篇文章或许会很有用<br><a target="_blank" rel="noopener" href="https://the-bilal-rizwan.medium.com/wordpress-xmlrpc-php-common-vulnerabilites-how-to-exploit-them-d8d3c8600b32">Wordpress xmlrpc.php -common vulnerabilites &amp; how to exploit them</a> 讲的很清晰</li>
</ul>
</blockquote>
<blockquote>
<p>目录枚举<br>有时开发人员会忘记禁用<code>/wp-content/uploads</code>上的目录列表。</p>
<p>检测：<br>&#x2F;wp-content&#x2F;uploads<br>可以将这个路径加入到模糊词表中</p>
<p>其实有一个目录爆破工具<a target="_blank" rel="noopener" href="https://github.com/OJ/gobuster">gobuster</a> 挺好用也挺强大的</p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/201984">Wordpress directories&#x2F;files visible to internet</a></li>
</ul>
</blockquote>
<blockquote>
<p>CVE-2018-6389<br>此问题可能会使 4.9.3 以下的任何 Wordpress 网站关闭。</p>
<p>检测：<br>利用下面链接内的 poc，在可疑的 Wordpress 站点请求，你在响应中会获得一堆的 js 数据：<br><a target="_blank" rel="noopener" href="https://gist.github.com/remonsec/4877e9ee2b045aae96be7e2653c41df9">loadsxploit</a></p>
<p>利用：<br>您可以使用任何 Dos 工具，Doser 好像很快，在 30 秒内关闭了 Web 服务器：<br><a target="_blank" rel="noopener" href="https://github.com/quitten/doser.py">Doser</a><br><code>python3 doser.py -t 999 -g &#39;https://site.com/fullUrlFromLoadsxploit&#39;</code></p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/752010">DoS of https://nordvpn.com/ via CVE-2018-6389 exploitation</a><br><a target="_blank" rel="noopener" href="https://baraktawily.blogspot.com/2018/02/how-to-dos-29-of-world-wide-websites.html">How to DoS 29% of the World Wide Websites - CVE-2018-6389</a> 原理讲的很详细</li>
</ul>
</blockquote>
<blockquote>
<p>CVE-2021-24364<br>5.4.4之前的Jannah WordPress主题在将其输出回页面之前，没有正确清理tie_get_user_weather AJAX操作中的选项JSON参数，导致了一个反映的跨站点脚本（XSS）漏洞。</p>
<p>检测并且利用：<br>把 <your_wp-site-here> 替换成你的 WP 站点请求即可等待弹窗：</your_wp-site-here></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Your_WP-Site-here</span>&gt;</span>/wp-admin/admin-ajax.php?action=tie_get_user_weather&amp;options=%7B%27location%27%3A%27Cairo%27%2C%27units%27%3A%27C%27%2C%27forecast_days%27%3A%275%3C%2Fscript%3E%3Cscript%3Ealert%28document.domain%29%3C%2Fscript%3Ecustom_name%27%3A%27Cairo%27%2C%27animated%27%3A%27true%27%7D</span><br></pre></td></tr></table></figure>

<blockquote>
<p>WP Cronjob DoS<br>你可以在这个区域也尝试一下 DoS。</p>
<p>检测：</p>
<ul>
<li>访问 site.com&#x2F;wp-cron.php</li>
<li>您将看到一个空白页面，其中包含 200 HTTP 状态码</li>
</ul>
<p>利用：<br>同样使用 Doser 来利用：<br><code>python3 doser.py -t 999 -g &#39;https://site.com/wp-cron.php&#39;</code></p>
<p><a target="_blank" rel="noopener" href="https://github.com/wpscanteam/wpscan/issues/1299">WP-Cron detection? </a><br><a target="_blank" rel="noopener" href="https://medium.com/@thecpanelguy/the-nightmare-that-is-wpcron-php-ae31c1d3ae30">The nightmare that is wp-cron.php</a></p>
</blockquote>
<blockquote>
<p>WP 用户枚举<br>仅当目标网站隐藏其当前用户或未公开可用时，此问题才会被接受。因此，攻击者更多是使用这些用户数据进行爆破。</p>
<p>检测：</p>
<ul>
<li>访问 site.com&#x2F;wp-json&#x2F;wp&#x2F;v2&#x2F;users&#x2F;</li>
<li>您将看到带有用户信息的 json 数据作为响应</li>
</ul>
<p>利用：</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">如果能联合 xmlrpc.php 方式的信息泄露，去请求，如使用</span><br><span class="line">*)wp.getUserBlogs</span><br><span class="line">*)wp.getCategories</span><br><span class="line">*)metaWeblog.getUsersBlogs）</span><br><span class="line">则能更准确的进行爆破，详见 xmlrpc.php 版块的 </span><br><span class="line">Wordpress xmlrpc.php -common vulnerabilites &amp; how to exploit them 文章</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/356047">Wordpress Users Disclosure (&#x2F;wp-json&#x2F;wp&#x2F;v2&#x2F;users&#x2F;)</a></li>
</ul>
</blockquote>
<h4><span id="moodle">Moodle</span></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://dewangpanchal98.medium.com/mass-hunting-xss-moodle-ed4b50c82516">Mass Hunting XSS — Moodle</a><br>确实一篇文章讲述清楚了 &#x3D; &#x3D;</p>
</blockquote>
<h3><span id="跨域资源共享cors">跨域资源共享（CORS）</span></h3><h4><span id="cors-配置错误">CORS 配置错误</span></h4><blockquote>
<p>单目标狩猎：</p>
<ol>
<li>用爬虫爬取目标网站并用 BurpSuite 截取请求与响应；</li>
<li>用 BurpSuite 寻找<code>Access-Control</code>；</li>
<li>尝试在请求中添加<code>Origin Header</code>，如<code>Origin:attacker.com</code>或<code>Origin:null</code>或<code>Origin:attacker.target.com</code>或<code>Origin:target.attacker.com</code>；</li>
<li>如果在响应中发现了 Origin 的相关信息，则目标站点可能存在错误的 CORS 配置。</li>
</ol>
</blockquote>
<blockquote>
<p>多目标（含子域）狩猎：</p>
<ol>
<li>子域发现：<code>subfinder -d target.com -o domains.txt</code>；</li>
<li>域名判活：<code>cat domains.txt | httpx | tee -a alive.txt</code>；</li>
<li>把每一个存活子域送进 BurpSuite：<code>cat alive.txt | parallel -j 10 curl --proxy &quot;http://127.0.0.1:8080&quot; -sk 2&gt;/dev/null</code>；</li>
<li>如单目标一般开始狩猎。</li>
</ol>
</blockquote>
<blockquote>
<p>憨批为什么不用自动化工具：<br><a target="_blank" rel="noopener" href="https://github.com/chenjj/CORScanner">CORScanner</a><br><a target="_blank" rel="noopener" href="https://github.com/lc/theftfuzzer">theftfuzzer</a><br><a target="_blank" rel="noopener" href="https://github.com/s0md3v/Corsy">Corsy</a><br><a target="_blank" rel="noopener" href="https://github.com/Shivangx01b/CorsMe">CorsMe</a></p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://www.jianjunchen.com/post/cors%E5%AE%89%E5%85%A8%E9%83%A8%E7%BD%B2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/">绕过浏览器SOP，跨站窃取信息：CORS配置安全漏洞报告及最佳部署实践</a> 讲得很好</li>
</ul>
</blockquote>
<blockquote>
<p>自动化狩猎：</p>
<ol>
<li>利用 subfinder、assetfinder、findomain 等工具搜寻子域：<code>subfinder -d target.com | tee -a hosts1 , findomain -t target.com | tee -a hosts1 , assetfinder --subs-only target.com |tee -a hosts1</code>；</li>
<li>之后做一下数据处理与判活：<code>cat hosts1 | sort -u | tee -a hosts2</code>，<code>cat hosts2 | httpx | tee -a hosts</code>；</li>
<li>看看这些 hosts 在终端有哪些路径回显；</li>
<li>然后试试 <code>meg -v</code>；</li>
<li>进程完成后再利用 gf 看看 CORS；</li>
<li>所有链接将携带<code>Access-Control-Allow</code>被展示出来。</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://github.com/tomnomnom/meg">meg</a><br><a target="_blank" rel="noopener" href="https://github.com/tomnomnom/gf">gf</a><br><a target="_blank" rel="noopener" href="https://github.com/projectdiscovery/subfinder">subfinder</a><br><a target="_blank" rel="noopener" href="https://github.com/tomnomnom/assetfinder">assetfinder</a><br><a target="_blank" rel="noopener" href="https://github.com/Findomain/Findomain">findomain</a><br><a target="_blank" rel="noopener" href="https://github.com/projectdiscovery/httpx">httpx</a></p>
</blockquote>
<h4><span id="cors-绕过">CORS 绕过</span></h4><blockquote>
<p>POC:</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Origin:null</span><br><span class="line">Origin:attacker.com</span><br><span class="line">Origin:attacker.target.com</span><br><span class="line">Origin:attackertarget.com</span><br><span class="line">Origin:sub.attackertarget.com</span><br><span class="line">Origin:attacker.com <span class="keyword">and</span> then change the method Get to post/Post to Get</span><br><span class="line">Origin:sub.attacker target.com</span><br><span class="line">Origin:sub.attacker%target.com</span><br><span class="line">Origin:attacker.com/target.com</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>参考<br>Twitter：<a target="_blank" rel="noopener" href="https://twitter.com/trbughunters/status/1287023673845612546">TR Bug Hunters@trbughunters</a><br>Twitter：<a target="_blank" rel="noopener" href="https://twitter.com/Paresh_parmar1/status/1265251507655630848">Paresh@Paresh_parmar1</a><br>Twitter：<a target="_blank" rel="noopener" href="https://twitter.com/Alra3ees/status/1141504347089584128">Emad Shanab - أبو عبد الله@Alra3ees</a></li>
</ul>
</blockquote>
<h3><span id="csrf">CSRF</span></h3><h4><span id="csrf-发现">CSRF 发现</span></h4><blockquote>
<ol>
<li><p>只需删除 CRSF token<br>毫不夸张地说，这是许多网络应用中常见的问题；</p>
</li>
<li><p>令牌未连接到会话<br>网络应用程序只检查了 token 的是否存在即有效性，并未检测它的归属性，可以看看：<br>Bob 的 token 对 Alice 有效吗？<br>任何匿名用户的 token 对 Alice 有效吗？</p>
</li>
<li><p>利用 Content-Type<br>移除 token 并且更换 Content-Type：<br>Urlencoded form -&gt; JSON<br>JSON -&gt; Urlencoded form<br>Urlencoded form -&gt; multipart form</p>
</li>
<li><p>转换请求方式 POST -&gt; GET<br>服务器可能会跳过对 GET 请求的 CSRF 检查并接受 URL 中的正文参数：</p>
</li>
</ol>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST /change_password</span><br><span class="line">POST body:</span><br><span class="line">new_password=qwerty</span><br><span class="line"></span><br><span class="line">GET /change_password?new_password=qwerty</span><br></pre></td></tr></table></figure>
<blockquote>
<ol start="5">
<li><p>PHP 类型戏法<br>使用松散的比较策略（&#x3D;&#x3D;，!&#x3D;）可能会导致意料之外的结果并产生 CSRF 绕过的风险：<br><code>&#123;&quot;action&quot;: &quot;delete&quot;, &quot;csrf&quot;: &quot;1bc...ade&quot;&#125;</code><br><code>&#123;&quot;action&quot;: &quot;delete&quot;, &quot;csrf&quot;: 0&#125;</code></p>
</li>
<li><p>双重 Cookie 提交<br>如果你能控制用户的 cookie，尝试把你自己的 CSRF token 都放置在 body 和 cookie 中，可以尝试：<br>Cookie 注入<br>任何子域的 XSS<br>子域接管</p>
</li>
</ol>
</blockquote>
<h4><span id="csrf-绕过">CSRF 绕过</span></h4><blockquote>
<p>CSRF 可能出现在登录，注销，重置凭证，更改密码，添加购物车，喜欢，评论，个人资料更改，用户详细信息更改，余额转移，订阅等位置：</p>
<ul>
<li>更改请求方法 [POST &#x3D;&gt; GET]</li>
<li>删除整个 token 参数</li>
<li>删除令牌，并给出一个空白参数</li>
<li>使用在另一个请求中未使用的有效令牌</li>
<li>使用自己的 CSRF token 将其提供给受害者</li>
<li>用相同长度的值替换 token</li>
<li>逆向工程令牌</li>
<li>通过 HTML 注入提取 Token</li>
<li>从 Non-Form <code>Content-Type: application/json</code>或<code>Content-Type: application/x-url-encoded</code>切换到<code>Content-Type: form-multipart</code></li>
<li>更改&#x2F;删除令牌中的最后一个或第一个字符</li>
<li>将<code>referrer</code>更改为<code>Referrer</code></li>
<li>绕过正则表达式<br>如果网站在引用的 URL 中寻找“bank.com”，那么“bank.com.attacker.com”或“attacker.com&#x2F;bank.com”可能会起作用。</li>
<li>删除引用标题（在您的 payload 或 html 代码中添加<code>&lt;meta name=”referrer” content=”no-referrer”&gt;</code>）</li>
<li>点击劫持<br>（如果您不熟悉点击劫持攻击，可以在<a target="_blank" rel="noopener" href="https://owasp.org/www-community/attacks/Clickjacking">OWASP</a> 找到更多信息。）<br>在同一端点上利用点击劫持会绕过所有 CSRF 保护。因为从技术上讲，请求确实来自合法站点。如果易受攻击的端点所在的页面容易受到点击劫持，则所有 CSRF 保护都将变得无关紧要，您将能够获得与端点上的 CSRF 攻击相同的结果，尽管需要付出更多努力。</li>
</ul>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://medium.com/swlh/intro-to-csrf-cross-site-request-forgery-9de669df03de">Intro to CSRF: Cross-Site Request Forgery</a><br><a target="_blank" rel="noopener" href="https://medium.com/swlh/attacking-sites-using-csrf-ba79b45b6efe">Attacking Sites Using CSRF</a><br><a target="_blank" rel="noopener" href="https://medium.com/swlh/bypassing-csrf-protection-c9b217175ee">Bypassing CSRF Protection</a><br>讲的都挺好的</li>
</ul>
</blockquote>
<h3><span id="寻找-cvefinding-cves">寻找 CVE（finding CVES）</span></h3><h4><span id="cves">CVES</span></h4><blockquote>
<ol>
<li>抓取所以子域，如<code>subfinder -d domain.com | tee -a domains.txt</code>；</li>
<li>寻找所有存活域，如<code>cat domains.txt | httpx -status-code | grep 200 | cut -d &quot; &quot; -f1 | tee -a alive.txt</code>；</li>
<li>利用 <a target="_blank" rel="noopener" href="https://github.com/projectdiscovery/nuclei">nuclei</a> 进行基本检测、面板检测、工作流检测、cve 模板检测，并把检测结果保存至不同文件中：<code>cat alive.txt | nuclei -t nuclei-templates/workflows | tee -a workflows</code>；</li>
<li>仔细且有耐心的查看输出；</li>
<li>在你的目标上发现些有趣的东西，比如使用了 Jira；</li>
<li>把该链接放入浏览器看看版本；</li>
<li>去找找看这个版本的 Jira 是否存在什么漏洞；</li>
<li>去寻找这个漏洞的各种 poc，包括别人可能改进的。</li>
</ol>
</blockquote>
<h3><span id="web-应用程序渗透测试检测清单">Web 应用程序渗透测试检测清单</span></h3><blockquote>
<p><a target="_blank" rel="noopener" href="https://kathan19.gitbook.io/howtohunt/checklist/web-application-pentesting-checklist">Web Application Pentesting Checklist</a><br><a target="_blank" rel="noopener" href="https://github.com/KathanP19/HowToHunt/blob/master/CheckList/Web_Checklist_by_Chintan_Gurjar.pdf">Web Checklist by Chintan Gurjar.pdf</a><br><a target="_blank" rel="noopener" href="https://github.com/KathanP19/HowToHunt/blob/master/CheckList/mindmap.png">Mindmap by Rohit Gautam</a><br><a target="_blank" rel="noopener" href="https://github.com/KathanP19/HowToHunt/blob/master/CheckList/Web_Penetration_Testing_Methodology%402x.png">Mindmap by Cristian Cornea</a><br>都挺有用的</p>
</blockquote>
<h3><span id="网页代码审计web-page-source-code-review">网页代码审计（Web Page Source Code Review）</span></h3><h4><span id="重要功能优先">重要功能优先</span></h4><blockquote>
<p>阅读源代码时，请专注于重要功能，例如身份验证，密码重置，状态更改操作和敏感信息读取。（什么是最重要的将取决于应用程序。然后，查看这些组件如何与其他功能交互。最后，审核应用程序的其他不太敏感的部分。</p>
</blockquote>
<h4><span id="跟随用户输入">跟随用户输入</span></h4><blockquote>
<p>另一种方法是遵循处理用户输入的代码。HTTP 请求参数、HTTP 标头、HTTP 请求路径、数据库条目、文件读取和文件上传等用户输入为攻击者利用应用程序漏洞提供了入口点。这也可能有助于我们找到一些关键漏洞，如xxe，xxs，sql注入。</p>
</blockquote>
<h4><span id="硬编码的密钥与凭据">硬编码的密钥与凭据</span></h4><blockquote>
<p>在源代码审查期间，可以轻松发现硬编码的机密，例如API密钥，加密密钥和数据库密码。您可以 grep 查找关键字，例如“key”、“secret”、“password”、“encrypt”或正则表达式，搜索十六进制或 base64 字符串（取决于所使用的密钥格式）。</p>
</blockquote>
<h4><span id="使用危险功能和过时的依赖关系">使用危险功能和过时的依赖关系</span></h4><blockquote>
<p>不受控制地使用危险功能和过时的依赖项是错误的巨大来源。Grep 以获取您正在使用的语言的特定函数，并搜索依赖项版本列表以查看它们是否过时。</p>
</blockquote>
<h4><span id="开发人员备注-隐藏的调试功能-配置文件和-git-目录">开发人员备注、隐藏的调试功能、配置文件和 .git 目录</span></h4><blockquote>
<p>这些是开发人员经常忘记的事情，它们使应用程序处于危险状态。开发人员的评论可以指出明显的编程错误，隐藏的调试功能通常会导致权限提升，配置文件允许攻击者收集有关您的基础架构的更多信息，最后，公开的.git目录允许攻击者重建您的源代码。</p>
</blockquote>
<h4><span id="隐藏路径-已弃用的端点和开发中的端点">隐藏路径、已弃用的端点和开发中的端点</span></h4><blockquote>
<p>这些是用户在正常使用应用程序时可能不会遇到的点。但是，如果它们有效并且被攻击者发现，则可能导致身份验证绕过和敏感信息泄漏等漏洞，具体取决于暴露的端点。</p>
</blockquote>
<h4><span id="弱密码或散列">弱密码或散列</span></h4><blockquote>
<p>这是一个在黑盒测试期间很难发现的问题，但在审查源代码时很容易发现。查找诸如弱加密密钥、可破解加密算法和弱哈希算法等问题。Grep 寻找 ECB、MD4 和 MD5 等术语。</p>
</blockquote>
<h4><span id="缺少对用户输入和正则表达式强度的安全检查">缺少对用户输入和正则表达式强度的安全检查</span></h4><blockquote>
<p>查看源代码是找出缺少哪种安全检查的好方法。通读应用程序的文档，并测试您可以想到的所有边缘情况。对于您应该考虑哪种边缘情况，一个很好的资源是<a target="_blank" rel="noopener" href="https://github.com/swisskyrepo/PayloadsAllTheThings">PayloadsAllTheThings</a> 。</p>
</blockquote>
<h4><span id="缺少-cookie-标志">缺少 Cookie 标志</span></h4><blockquote>
<p>注意缺少的 cookie 标志，例如<code>httponly</code>和<code>security</code>。 </p>
</blockquote>
<h4><span id="意外行为-条件与不必要的复杂函数">意外行为、条件与不必要的复杂函数</span></h4><blockquote>
<p>此外，还要特别注意应用程序的意外行为、条件和复杂函数。这些位置是经常发现晦涩错误的地方。</p>
</blockquote>
<h3><span id="没有剥离的-exif-地理数据exif-geo-data-not-stripped">没有剥离的 EXIF 地理数据（EXIF Geo Data Not Stripped）</span></h3><h4><span id="介绍">介绍</span></h4><blockquote>
<p>当用户在 example.com 上传图像时，上传图像的EXIF地理位置数据不会被剥离。因此，任何人都可以获得 example.com 用户的敏感信息，例如他们的地理位置，他们的设备信息，例如设备名称，版本，使用的软件和软件版本等。</p>
</blockquote>
<h4><span id="复现步骤">复现步骤</span></h4><blockquote>
<ol>
<li>在 <a target="_blank" rel="noopener" href="https://github.com/ianare/exif-samples/tree/master/jpg">exif-samples</a> 上能找到很多不同分辨率及大小的图片；</li>
<li>去一个上传图片的站点，上传 exif-example 中符合规则的图片；</li>
<li>查看上传图片的路径（要么右键单击图片然后复制图片地址，要么右键单击，检查图片，URL将进入检查，将其编辑为html）；</li>
<li>现在用<a target="_blank" rel="noopener" href="http://exif-viewer.com/">Online Exif Viewer</a> 看看那个图片链接有没有暴露有效信息。</li>
</ol>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/906907">IDOR with Geolocation data not stripped from images</a></li>
</ul>
</blockquote>
<h3><span id="文件上传绕过file-upload-bypass">文件上传绕过（File Upload Bypass）</span></h3><blockquote>
<p>假设有一个限制，你只能以PDF、JPEG、JPG等几种格式上传文件，但如果你可以通过无视这种上传机制和文件类型检查来上传一个PHP文件会如何？<br>如果有人能上传一个PHP文件，那么一旦他上传一个 php shell，就可以轻松的执行 RCE，最不济也能在服务器上获得一个反弹 shell。</p>
</blockquote>
<h4><span id="绕过的原理">绕过的原理</span></h4><blockquote>
<p>这一般取决于系统使用哪种验证，如果他只是对文件的扩展名进行校验，那么绕过他将非常容易。<br>现在假设我们必须上传一个JPG文件，即拓展名必须是 XX.jpg：</p>
</blockquote>
<h4><span id="绕过一般的拓展验证">绕过一般的拓展验证</span></h4><blockquote>
<p>上传一个以 .php.jpg 或 .jpg.php 为拓展名的文件试试</p>
</blockquote>
<h4><span id="绕过魔术字节验证">绕过魔术字节验证</span></h4><blockquote>
<p>在这种绕过中我们使用 polygots.在安全相关文章中，Polyglots 是指多语言且多种不同文件类型有效形式的结合。<br>例如，GIFAR 文件既是一种 GIF 又是一种 RAR 文件。也有文件能既是 GIF 又是 JS，既是 PPT 又是 JS 等等。</p>
<p>所以当我们被要求要上传一个 JPEG 类型的文件时我们可以上传一个 PHAR-JPEG 文件，因为 PHAR-JPEG 文件同时具有 JPEG 标头和 PHP 文件内容，在验证时会被视为 JPEG 文件，稍做处理后可被作为 PHP 文件被利用。<br>但是，如果你没有网站文件上传测试的许可，请不要进行文件上传测试，除非你想进行恶意行为（文件上传将留有痕迹和脏数据，这是服务器不想承受的，所以没有许可就不要试了，也没钱拿）。</p>
</blockquote>
<h4><span id="绕过步骤">绕过步骤</span></h4><blockquote>
<ol>
<li>创建具有应用程序接受拓展名的恶意文件；</li>
<li>上传该文件后，确认（发送）；</li>
<li>在 Burpsuite 中捕获请求，将文件拓展名修改为所需的恶意拓展名，某些情况下你可能还需需要修改文件的内容类型；</li>
<li>将请求转发至服务器，看看响应状态，在页面尝试触发恶意文件。</li>
</ol>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://github.com/jonaslejon/malicious-pdf">malicious-pdf</a> - 恶意 PDF 生成器</li>
</ul>
</blockquote>
<h3><span id="溯源find-origin">溯源（Find Origin）</span></h3><h4><span id="验证-waf">验证 WAF</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dig +short example.com</span><br><span class="line">curl -s https://ipinfo.io/IP | jq -r <span class="string">&#x27;.org&#x27;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>借助 AWS，你通常可以识别存在<code>AWSLB</code>和<code>AWSLBCORS</code> Cookie 的负载均衡器</p>
</blockquote>
<h4><span id="确定来源">确定来源</span></h4><blockquote>
<p>用<a target="_blank" rel="noopener" href="https://dnsdumpster.com/">dnsdumpster</a> 可以生成域名地图<br>接下来用<a target="_blank" rel="noopener" href="https://censys.io/">Censys</a> 进行搜索，并将看起来与目标匹配的ip保存在文本文件中。如<code>https://censys.io/ipv4?q=0x00sec.org</code><br>找到与域绑定的IP的另一种方法是查看其历史IP。可以用<a target="_blank" rel="noopener" href="https://securitytrails.com/domain/0x00sec.org/dns">SecurityTrails DNS trails</a> 跟踪</p>
<ul>
<li>在这里我们能看到存在的A记录及存在的时间。管理员在使用多年的“裸机”后切换到 WAF 解决方案是非常常见的，但他们不一定会配置白名单。</li>
<li>你可以把输出的结果表格整个复制保存在txt中，然后用一下 awk 过滤出 ip：</li>
</ul>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -E -o <span class="string">&quot;([0-9]&#123;1,3&#125;[\\.])&#123;3&#125;[0-9]&#123;1,3&#125;&quot;</span> tails.txt | <span class="built_in">sort</span> -u | <span class="built_in">tee</span> -a ips.txt</span><br></pre></td></tr></table></figure>

<h4><span id="域名系统枚举">域名系统枚举</span></h4><blockquote>
<p>如果枚举目标 DNS，你有可能发现他们具有类似<code>dev.example.com</code>或<code>staging.example.com</code>子域的内容，并且它可能指向没有 WAF 的源主机</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- Get all the subdomains.</span><br><span class="line">    `subfinder -silent -d 0x00sec.org | dnsprobe -silent | awk  <span class="string">&#x27;&#123; print $2 &#125;&#x27;</span>  | <span class="built_in">sort</span> -u | <span class="built_in">tee</span> -a ips.txt`</span><br></pre></td></tr></table></figure>

<h4><span id="检查主机ip">检查主机IP</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> ip <span class="keyword">in</span> $(<span class="built_in">cat</span> ips.txt) <span class="comment"># iterate through each line in file</span></span><br><span class="line"><span class="keyword">do</span> </span><br><span class="line">    org=$(curl -s &lt;https://ipinfo.io/<span class="variable">$ip</span>&gt; | jq -r <span class="string">&#x27;.org&#x27;</span>) <span class="comment">#  Get Org from IPInfo</span></span><br><span class="line">  title=$(<span class="built_in">timeout</span> 2 curl -s -k -H <span class="string">&quot;Host: 0x00sec.org&quot;</span> &lt;https://<span class="variable">$ip</span>/&gt; | pup <span class="string">&#x27;title text&#123;&#125;&#x27;</span>) <span class="comment"># Get title</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;IP: <span class="variable">$ip</span> Title: <span class="variable">$title</span> Org: <span class="variable">$org</span>&quot;</span> <span class="comment"># Print results</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样我们就能大致快速浏览出哪个IP对应哪个 Host header，并且知道标题<br>我们遍历了每个主机，直接用 host header 请求IP，且我们有我们的源IP</p>
</blockquote>
<h4><span id="手动设置-host-header">手动设置 Host Header</span></h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -k -H <span class="string">&quot;Host: 0x00sec.org&quot;</span> https://&lt;ip address&gt;/</span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者直接在 Burpsuite 中设置 Host Header</p>
</blockquote>
<h4><span id="cloudfail">CloudFail</span></h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone &lt;https://github.com/m0rtem/CloudFail.git&gt;</span><br><span class="line">cd CloudFail</span><br><span class="line">pip install -r requirements.txt</span><br><span class="line">python3 cloudfail.py -t 0x00sec.org</span><br></pre></td></tr></table></figure>

<h4><span id="事先侦察">事先侦察</span></h4><blockquote>
<p>一般的侦察过程是为了尽可能的获得更多的ip地址（host, nslookup, whois, ranges…），然后检查哪些服务器启用了 Web 服务（netcat, nmap, masscan）<br>一旦拥有了这些 Web 服务器的IP列表后，下一步就是检查其中一个服务器上的受保护域是否配置为虚拟主机</p>
</blockquote>
<h4><span id="censys">Censys</span></h4><blockquote>
<p>在选择输入中选择<code>Certificates</code>，提供目标域，然后点击<code>\</code><br>你应该会看到适合你目标的证书列表<br>单机每个结果以显示详细信息，然后在最右侧的<code>Explore</code>菜单中选择<code>IPv4 Hosts</code><br>你应该能够看到使用证书的服务器的IP地址<br>从这里开始，获取所有可能的IP，然后回到上一节，尝试通过所有这些IP访问你的目标：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -s -k -H <span class="string">&quot;Host: 0x00sec.org&quot;</span> https://&lt;ip address&gt;/</span><br></pre></td></tr></table></figure>

<h4><span id="邮件头">邮件头</span></h4><blockquote>
<p>下一步是检索目标发出的邮件中的标题：订阅新闻通讯、创建账户、使用“忘记密码”功能、订购某些东西……简而言之，尽一切努力从你正在测试的网站获取电子邮件<br>收到电子邮件后，请检查来源，尤其是标题。记录你可以在那里找到的所有IP，以及可能属于托管服务的子域。然后，再次尝试通过所有这些来访问你的目标。<br><a target="_blank" rel="noopener" href="https://www.postmastery.com/about-the-return-path-header/">The value of header Return-Path worked pretty well</a></p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://delta.navisec.io/a-pentesters-guide-part-5-unmasking-wafs-and-finding-the-source/">溯源（Find Origin）实现上部分</a><br><a target="_blank" rel="noopener" href="https://blog.detectify.com/2019/07/31/bypassing-cloudflare-waf-with-the-origin-server-ip-address/">溯源（Find Origin）实现下部分</a></li>
</ul>
</blockquote>
<h3><span id="graphql">GraphQL</span></h3><h4><span id="videos">Videos</span></h4><blockquote>
<p>GraphQL Video - <a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=GlvNwhq-uBg">InsiderPhd</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=NPDp7GHmMa0">REST in Peace: Abusing GraphQL to Attack Underlying Infrastructure - LevelUp 0x05</a></p>
</blockquote>
<h4><span id="blogs">Blogs</span></h4><blockquote>
<p>Exploit GraphQL - <a target="_blank" rel="noopener" href="https://blog.yeswehack.com/yeswerhackers/how-exploit-graphql-endpoint-bug-bounty/">Yeswehack Blog</a><br>Hacking GraphQL - <a target="_blank" rel="noopener" href="https://infosecwriteups.com/hacking-graphql-for-fun-and-profit-part-1-understanding-graphql-basics-72bb3dd22efa">Part1</a> <a target="_blank" rel="noopener" href="https://infosecwriteups.com/hacking-graphql-for-fun-and-profit-part-2-methodology-and-examples-5992093bcc24">Part2</a><br><a target="_blank" rel="noopener" href="https://blog.doyensec.com/2021/05/20/graphql-csrf.html">That single GraphQL issue that you keep missing</a><br><a target="_blank" rel="noopener" href="https://swizec.com/blog/reverse-engineer-a-graphql-api-to-automate-love-notes-codewithswiz-24/">Reverse engineer a GraphQL API</a><br><a target="_blank" rel="noopener" href="https://blog.assetnote.io/2021/08/29/exploiting-graphql/">Exploit GraphQL</a><br><a target="_blank" rel="noopener" href="https://twitter.com/holybugx/status/1441460070387261440?s=21">GraphQL Resources Thread</a></p>
</blockquote>
<h4><span id="tools">Tools</span></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://ivangoncharov.github.io/graphql-voyager/">GraphQL Voyager</a><br><a target="_blank" rel="noopener" href="https://devhints.io/graphql">GraphQL Cheatsheet</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=JJmufWfVvyU">AutoGraphQL</a><br><a target="_blank" rel="noopener" href="https://github.com/dolevf/graphw00f">graphw00f</a><br><a target="_blank" rel="noopener" href="https://portswigger.net/bappstore/296e9a0730384be4b2fffef7b4e19b1f">InQL - Introspection GraphQL Scanner</a></p>
</blockquote>
<h4><span id="labs">Labs</span></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/dolevf/Damn-Vulnerable-GraphQL-Application">Damn-Vulnerable-GraphQL-Application</a></p>
</blockquote>
<h3><span id="http-走私漏洞http_desync-attack">HTTP 走私漏洞（HTTP_Desync Attack）</span></h3><h4><span id="基础概念">基础概念</span></h4><blockquote>
<p>HTTP 请求夹带攻击是一种干扰站点处理从一个或多个用户接收 HTTP 请求队列的技术。请求夹带攻击通常十分严重，它允许攻击者绕过安全控制、未经授权访问敏感数据并直接危害其他应用程序用户。</p>
</blockquote>
<h4><span id="攻击位置">攻击位置</span></h4><blockquote>
<p>任何端点都有可能受到 HTTP 走私攻击（数据接收不同步攻击）<br>你也可以在非端点上寻找漏洞，但敏感端点收到的影响明显更高</p>
<ul>
<li><p>第一步：<br>利用 Burpsuite 的 Repeater 模块，尝试寻找各种基于时间的 payload 去确认漏洞是否存在：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/finding">Find the Vulnerability</a></p>
</li>
<li><p>第二步：<br>一旦你成功发现了 BUG，你可以尝试用任何 EXP 链接它，如通过窃取会话 id 接管账户，在 User-Agent Header 使用 XSS 攻击等：<a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling/exploiting">Exploiting the Vulnerability</a></p>
</li>
</ul>
</blockquote>
<h4><span id="实用工具">实用工具</span></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/defparam/smuggler">defparam’s_smuggler.py</a></p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">Smuggler.py :</span><br><span class="line"><span class="built_in">cat</span> alive_urls.txt | python3 smuggler.py -m GET/POST <span class="comment">#either GET or POST</span></span><br><span class="line">OR</span><br><span class="line">python3 smuggler.py -u https://example.com -m GET/POST</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/PortSwigger/http-request-smuggler">Burp_smuggler</a></p>
</blockquote>
<h4><span id="topics">Topics</span></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://paper.seebug.org/1049/">Protocol Layer Attack - HTTP Request Smuggling</a><br><a target="_blank" rel="noopener" href="https://portswigger.net/research/http-desync-attacks-request-smuggling-reborn">HTTP Desync Attacks: Request Smuggling Reborn</a><br><a target="_blank" rel="noopener" href="https://portswigger.net/web-security/request-smuggling">HTTP request smuggling</a></p>
</blockquote>
<h4><span id="reports">Reports</span></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://hackerone.com/reports/737140">Mass account takeovers using HTTP Request Smuggling on https://slackb.com/ to steal session cookies</a><br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/867952">HTTP request Smuggling</a><br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/498052">Password theft login.newrelic.com via Request Smuggling</a><br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/526880">Request smuggling on ████████</a><br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/771666">Stealing Zomato X-Access-Token: in Bulk using HTTP Request Smuggling on api.zomato.com</a><br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/753939">HTTP SMUGGLING EXPOSED HMAC&#x2F;DOS</a><br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/648434">Multiple HTTP Smuggling reports</a><br><a target="_blank" rel="noopener" href="https://hackerone.com/reports/740037">Request smuggling on admin-official.line.me could lead to account takeover</a></p>
</blockquote>
<h4><span id="writeups">Writeups</span></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://ricardoiramar.medium.com/the-powerful-http-request-smuggling-af208fafa142">The Powerful HTTP Request Smuggling</a><br><a target="_blank" rel="noopener" href="https://medium.com/cyberverse/http-request-smuggling-in-plain-english-7080e48df8b4">HTTP Request Smuggling in Plain English</a><br><a target="_blank" rel="noopener" href="https://medium.com/@cc1h2e1/write-up-of-two-http-requests-smuggling-ff211656fe7d">Write up of two HTTP Requests Smuggling</a><br><a target="_blank" rel="noopener" href="https://infosecwriteups.com/crossing-the-borders-the-illegal-trade-of-http-requests-57da188520ca">Crossing The Borders : The illegal trade of HTTP requests</a></p>
</blockquote>
<h4><span id="extra">Extra</span></h4><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=gzM4wWA7RFo">HTTP Request Smuggling mass account takeover</a></p>
</blockquote>
<h3><span id="host-header-attack">Host-Header Attack</span></h3><h4><span id="host-header-摘要">Host Header 摘要</span></h4><blockquote>
<p><img src="https://pbs.twimg.com/media/ET39wJOWoAAfTBb?format=jpg&name=small" alt="image"></p>
</blockquote>
<h4><span id="在测试试也要注意这些">在测试试也要注意这些</span></h4><blockquote>
<p>1.在请求中再添加一个 <code>Host:</code><br>2.尝试加入这些 Header：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">X-Original-Url:</span><br><span class="line">X-Forwarded-Server:</span><br><span class="line">X-Host:</span><br><span class="line">X-Forwarded-**Host**:</span><br><span class="line">X-Rewrite-Url:</span><br></pre></td></tr></table></figure>

<blockquote>
<p>3.如果你在任何 AEM 实例中查找攻击点时，遇到<code>api.json</code>，可以通过以下 Header 尝试 Web 缓存中毒：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host:</span><br><span class="line">X-Forwarded-Server:</span><br><span class="line">X-Forwarded-Host:</span><br><span class="line">https://localhost/api.json HTTP/1.1</span><br></pre></td></tr></table></figure>

<blockquote>
<p>4.也可以试试 <code>Host: redacted.com.evil.com</code><br>5.试试 <code>Host: evil.com/redacted.com</code> <a target="_blank" rel="noopener" href="https://hackerone.com/reports/317476">Account Takeover in Periscope TV</a><br>6.再来 <code>Host: example.com?.mavenlink.com</code><br>7.还可以试试 XSS <code>Host: javascript:alert(1);</code> <a target="_blank" rel="noopener" href="https://blog.bentkowski.info/2015/04/xss-via-host-header-cse.html">XSS via Host header - www.google.com/cse</a><br>8.<a target="_blank" rel="noopener" href="https://logicbomb.medium.com/bugbounty-database-hacked-of-indias-popular-sports-company-bypassing-host-header-to-sql-7b9af997c610">Host Header to Sqli</a><br>9.绕过前端服务器限制并且可以访问隐藏的文件目录：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">X-Rewrite-Url/X-original-url: curl -i -s -k -X <span class="string">&#x27;GET&#x27;</span> -H <span class="string">&#x27;Host: &lt;site&gt;&#x27;</span> -H <span class="string">&#x27;X-rewrite-url: admin/login&#x27;</span> <span class="string">&#x27;https://&lt;site&gt;/&#x27;</span></span><br></pre></td></tr></table></figure>

<h3><span id="html-injection">HTML-Injection</span></h3><h4><span id="摘要">摘要</span></h4><blockquote>
<p>密码重置链接通常指向你的帐户名称，后跟重置链接。如果应用程序允许你使用带有标签或特殊字符的帐户名，或许你该尝试以下注入。</p>
</blockquote>
<h4><span id="步骤">步骤</span></h4><blockquote>
<p>1.创建你的帐户<br>2.将你的姓名编辑为 <code>&lt;h1&gt;attacker&lt;/h1&gt;</code> 或 <code>&quot;abc&gt;&lt;h1&gt;attacker&lt;/h1&gt;</code> 并且保存它<br>3.发起一个重置密码请求并且在你的邮箱中验证<br>4.你将会发现 <code>&lt;h1&gt;</code> 标签被解析了</p>
<ul>
<li>HTML注入通常被认为只是低到中的威胁，但是你可以通过使用 <code>href</code> 来增加严重性：</li>
<li><code>&lt;h1&gt;attacker&lt;/h1&gt;&lt;a href=&quot;your-controlled-domain&quot;Click here&lt;/a&gt;</code></li>
<li>你可以将用户重定向到恶意域，并提供伪造的重置密码页面以窃取凭据，还可以提供 XSS 页面并窃取用户 cookie 等</li>
</ul>
</blockquote>
<h3><span id="idor">IDOR</span></h3><h4><span id="idor">IDOR</span></h4><blockquote>
<ul>
<li>IDOR 的核心是一种访问控制漏洞，其中应用程序依赖于用户提供的输入来直接引用对象。在这种情况下，对象可以是图片、帖子评论、与用户甚至组织内整个部门关联的个人身份信息（PII）</li>
<li>当应用程序根据用户提供的输入提供对象的直接访问时，会发生不安全的直接对象引用。通过此漏洞，攻击者可以直接绕过授权并访问系统中的资源，例如数据库记录或文件。不安全的直接对象引用允许攻击者通过修改用于直接指向对象的参数值来绕过授权并 直接访问资源。此类资源可以是属于其他用户的数据库条目、系统中的文件等。</li>
<li>IDOR 可以存在于整个应用程序中，因此建议你如果看到ID就测试一下，即使是 <code>guid</code> 或某种类型的“加密ID”。寻找此ID的潜在泄露（public profile），或寻找遍历点，看看能否利用 Burpsuite Intruder 进行测试。</li>
</ul>
</blockquote>
<h4><span id="你可能发现的-idor-类型">你可能发现的 IDOR 类型</span></h4><blockquote>
<p>1.参数值直接用于检索数据库记录：<code>http://foo.bar/somepage?invoice=12345</code><br>2.参数值直接用于在系统中执行操作：<code>http://foo.bar/changepassword?user=someuser</code><br>3.参数值直接用于检索文件系统资源：<code>http://foo.bar/showImage?img=img00011</code><br>4.参数值直接用于访问应用程序功能：<code>http://foo.bar/accessPage?menuitem=12</code></p>
</blockquote>
<h4><span id="测试-idor-手动方法">测试 IDOR - （手动方法）</span></h4><blockquote>
<p>基本步骤：<br>1.如果可以的话，先创建两个帐户，或枚举用户；<br>2.查看终端节点是私有的还是公共的，是否包含任何类型的 id 类参数；<br>3.尝试更改此参数值为其他用户的参数值，看看是否能以其他用户的身份进行操作。</p>
</blockquote>
<blockquote>
<p>Test-1：将 id 参数添加到没有 id 的请求</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /api/MyPictureList → /api/MyPictureList?user_id=&lt;other_user_id&gt;</span><br><span class="line"></span><br><span class="line">你可以通过删除或编辑其他对象并查看使用的参数名称来寻找要尝试修改或添加的参数名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-2:尝试替换参数名称</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instead of this:</span><br><span class="line">GET /api/albums?album_id=&lt;album id&gt;</span><br><span class="line"></span><br><span class="line">Try This:</span><br><span class="line">GET /api/albums?account_id=&lt;account id&gt;</span><br><span class="line"></span><br><span class="line">有一个名为 Paramalyzer 的 Burp 拓展，可以通过记住你传递给服务器的所有参数来方便修改</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-3：为同一个参数提供多个值</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instead of this:</span><br><span class="line">GET /api/account?id=&lt;your account id&gt; →</span><br><span class="line"></span><br><span class="line">Try this:    </span><br><span class="line">GET /api/account?id=&lt;your account id&gt;&amp;id=&lt;admin&#x27;s account id&gt;</span><br><span class="line"></span><br><span class="line">这也是 HTTP 参数污染的一种，这样的操作可能会让你访问管理员帐户</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-4：在测试 id 类参数时尝试更改 HTTP 的请求方法</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instead of this:</span><br><span class="line">POST /api/account?id=&lt;your account id&gt; →</span><br><span class="line"></span><br><span class="line">Try this:    </span><br><span class="line">PUT /api/account?id=&lt;your account id&gt;</span><br><span class="line"></span><br><span class="line">尝试切换 POST 和 PUT，看看是否可以将内容上传到其他用户的个人资料，对于 RESTful 服务，请尝试将 GET 更改为 POST/PUT/DELETE 以进行创建/更新/删除操作</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-5：尝试更改请求的内容类型</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Instead of this:</span><br><span class="line">POST /api/chat/join/123 […] Content-type: application/xml → test</span><br><span class="line"></span><br><span class="line">Try this:</span><br><span class="line">POST /api/chat/join/123 […] Content-type: application/json &#123;“user”: “test”&#125;</span><br><span class="line"></span><br><span class="line">访问控制在不同内容类型中的实施可能不一致。不要忘记尝试替换或使用不太常见的值，如 text/xml、text/x-json 等</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-6：尝试更改请求的文件类型（测试是否为Ruby）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Example:</span><br><span class="line"></span><br><span class="line">GET /user_data/2341 --&gt; 401 Unauthorized</span><br><span class="line"></span><br><span class="line">GET /user_data/2341.json --&gt; 200 OK</span><br><span class="line"></span><br><span class="line">通过附加不同的文件扩展名（e.g. .json, .xml, .config）在文件请求的末尾</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-7：应用是否要求非数字 id？将其改为数字 id</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">可能有多种方法引用数据库中的对象，并且应用程序仅对一种对象进行访问控制</span><br><span class="line">在接受非数字 id 的任何地方尝试使用数字 id：</span><br><span class="line">Example:</span><br><span class="line"></span><br><span class="line">username=user1 → username=1234</span><br><span class="line">account_id=7541A92F-0101-4D1E-BBB0-EB5032FE1686 → account_id=5678</span><br><span class="line">album_id=MyPictures → album_id=12</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-8：尝试使用数组</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果常规 id 替换不起作用，请尝试将 id 包装在数组中，看看是否可以达成操作：</span><br><span class="line"></span><br><span class="line">&#123;“id”:19&#125; → &#123;“id”:[19]&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-9：通配符 id</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">尝试将 id 参数值替换为通配符，你可能会幸运地得到什么：</span><br><span class="line"></span><br><span class="line">GET /api/users/&lt;user_id&gt;/ → GET /api/users/*</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Test-10：注意新功能</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果你偶然发现 Web 应用中新添加的功能（如即将举行的活动中含有上传个人资料图片的功能），可能会执行 API 调用：</span><br><span class="line"></span><br><span class="line">/api/CharityEventFeb2021/user/pp/&lt;ID&gt;</span><br><span class="line"></span><br><span class="line">应用程序可能不会像对核心功能那样严格地强制实施此新功能的访问控制</span><br></pre></td></tr></table></figure>

<blockquote>
<p>IDOR - 自动测试方式：<br><a target="_blank" rel="noopener" href="https://threat.tevora.com/finding-broken-access-controls/">Finding Broken Access Controls</a><br><a target="_blank" rel="noopener" href="https://blog.yeswehack.com/yeswerhackers/pimpmyburp-pwnfox-autorize-find-idor/">PimpMyBurp #1 - PwnFox + Autorize: The perfect combo to find IDOR - Global Bug Bounty Platform</a><br><a target="_blank" rel="noopener" href="https://medium.com/cyberverse/automating-burp-to-find-idors-2b3dbe9fa0b8">Automating BURP to find IDORs</a></p>
<ul>
<li>参考<br><a target="_blank" rel="noopener" href="https://medium.com/@aysebilgegunduz/everything-you-need-to-know-about-idor-insecure-direct-object-references-375f83e03a87">Everything You Need to Know About IDOR (Insecure Direct Object References)</a><br><a target="_blank" rel="noopener" href="https://www.aon.com/cyber-solutions/aon_cyber_labs/finding-more-idors-tips-and-tricks/">Finding more IDORs - Tips and Tricks | Aon</a><br><a target="_blank" rel="noopener" href="https://github.com/KathanP19/HowToHunt/blob/master/IDOR/IDOR-Old.md">KathanP19&#x2F;HowToHunt</a><br><a target="_blank" rel="noopener" href="https://www.bugbountyhunter.com/vulnerability/?type=idor">Learn about Insecure Object Reference (IDOR) | BugBountyHunter.com</a><br><a target="_blank" rel="noopener" href="https://owasp.org/www-project-web-security-testing-guide/v42/4-Web_Application_Security_Testing/05-Authorization_Testing/04-Testing_for_Insecure_Direct_Object_References.html">WSTG - v4.2</a><br><a target="_blank" rel="noopener" href="https://notes.mufaddal.info/web/idor">IDOR (Insecure Direct Object Reference)</a><br><a target="_blank" rel="noopener" href="https://medium.com/@Sm9l/what-i-learnt-from-reading-220-idor-bug-reports-6efbea44db7">What I learnt from reading 220* IDOR bug reports.</a></li>
</ul>
<p>Medium 报告：<br><a target="_blank" rel="noopener" href="https://mokhansec.medium.com/full-account-takeover-worth-1000-think-out-of-the-box-808f0bdd8ac7">Full account takeover worth $1000 Think out of the box</a><br><a target="_blank" rel="noopener" href="https://infosecwriteups.com/all-about-getting-first-bounty-with-idor-849db2828c8">All About Getting First Bounty with IDOR</a><br><a target="_blank" rel="noopener" href="https://vedanttekale20.medium.com/idor-that-allowed-me-to-takeover-any-users-account-129e55871d8">IDOR that allowed me to takeover any users account.</a><br><a target="_blank" rel="noopener" href="https://betterprogramming.pub/all-about-idor-attacks-64c4203b518e">All About IDOR Attacks</a><br><a target="_blank" rel="noopener" href="https://amineaboud.medium.com/access-developer-tasks-list-of-any-of-facebook-application-graphql-idor-62307c5e5b34">Access developer tasks list of any of Facebook Application (GraphQL IDOR)</a></p>
<p>Tips</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#1 https://twitter.com/M0_SADAT/status/1361289751597359105</span><br><span class="line">Looking for high impact IDOR?</span><br><span class="line">Always try to find the hidden parameters for this endpoints using Arjun and Parameth</span><br><span class="line">/settings/profile</span><br><span class="line">/user/profile</span><br><span class="line">/user/settings</span><br><span class="line">/account/settings</span><br><span class="line">/username</span><br><span class="line">/profile</span><br><span class="line">And any payment endpoint</span><br><span class="line"></span><br><span class="line">Pro tip: Don’t forget to try create/update/delete operations on objects that are publicly readable but shouldn’t be writable. Can you PUT to /api/products and change a price?</span><br></pre></td></tr></table></figure>

<h3><span id="jwt">JWT</span></h3><h4><span id="介绍">介绍</span></h4><blockquote>
<p>JWT 最常用于授权。<br>JSON Web 令牌 （JWT） 是一种标准化格式，用于在双方之间安全地交换数据。<br>它是紧凑的、可读的，并且由身份提供者 （IdP） 使用私钥&#x2F;或公钥对进行数字签名。因此，令牌的完整性和真实性可以由其他相关方进行验证。<br>使用 JWT 的目标不是隐藏数据，而是确保数据的真实性。JWT 是经过签名和编码的，而不是加密的。<br>JWT 是一种基于令牌的无状态身份验证机制。由于它是客户端无状态会话，因此服务器不必仅依靠数据存储（数据库）来保存会话信息。</p>
<p>它由三个要素组成：<code>header.payload.signature</code><br>1.标头 -  JWT 标头由用于签名和编码的令牌类型和算法组成。算法可以是HMAC，SHA256，RSA，HS256或RS256。<br>2.有效负载 -  这也是一个 JSON 对象，用于存储用户的信息，如 ID、用户名、角色、令牌生成时间和其他自定义声明。<br>3.签名 -  JSON Web 令牌最关键的方面是其签名 （JWT）。签名是通过使用 Base64url 编码对标头和有效负载进行编码并使用句点分隔符 （.）。此信息随后传递到加密算法。因此，如果标头或有效负载发生更改，则必须再次计算签名。只有身份提供程序 （IdP） 有权访问用于生成签名的私钥，这禁止令牌操作。</p>
<p>JWT 可以使用称为对称和非对称加密的两种加密机制生成：<br>对称：此机制需要单个密钥来创建和验证 JWT。这种类型的最常见算法是HS256。<br>非对称：此机制需要公钥进行验证，需要私钥对签名进行签名。这种类型的最常见算法是RS256。</p>
<p>密钥 ID（kid）是具有字符串类型的可选标头，用于标识文件系统或数据库中的特定密钥，然后使用其内容验证签名。如果应用程序具有多个用于对令牌进行签名的密钥，则此参数很有用，但如果它是可注入的，则可能会出现问题，因为攻击者可以引用具有可预测内容的特定文件。</p>
<p>除了密钥 ID 之外，JSON Web 令牌标准还为开发人员提供了通过 URL 指定密钥的能力。<br>令牌标头包含版本（“ver”）声明。它包含所使用的 JWT 令牌库的版本。<br>jku 标头参数 - JKU 是“JWK Set URL”的缩写。它是一个可选的标头字段，用于指定引用验证令牌所需的密钥集合的 URL。如果未正确控制此字段且允许此字段，则攻击者可能会托管自己的密钥文件，并声明应用程序使用它来验证令牌。<br>jwk 标头参数 - 可选的 JWK（JSON Web 密钥）标头参数允许攻击者将用于验证令牌的密钥直接嵌入到令牌中。<br>x5u 和 x5c 标头参数 - x5u 和 x5c 标头参数（如 jku 和 jwk 标头）允许攻击者定义用于验证令牌的公钥证书或证书链。 x5u 以 URI 形式定义信息，而 x5c 允许将证书数据合并到令牌中。<br>x5t 参数 - “x5t”（x.509 证书指纹）标头参数返回 X.509 证书的 DER 编码的 base64url 编码的 SHA-256 指纹（即摘要），可用于匹配证书。结果，它相当于密钥标识符或孩子声明！！</p>
<p>在有效负载部分，你可能还会发现：<br>JTI 参数，用于防止对 JWT 的重放攻击<br>iss 参数 - 颁发令牌的实体名称<br>iat 参数 - 标识不得接受 JWT 令牌进行处理的时间</p>
</blockquote>
<h3><span id="未完待续">未完待续</span></h3>

        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/Exploit/" rel="tag">Exploit</a><a class="tag-none-link" href="/tags/SRC/" rel="tag">SRC</a><a class="tag-none-link" href="/tags/Skadi/" rel="tag">Skadi</a>
            </div>
        

    </section>
</article>
  
</section>


        <script>setLoadingBarProgress(60);</script>
    </main>

    <footer id="footer" class="clearfix">

    

    <div class="social-wrapper">
        
            
                <a href="https://github.com/artchen" class="social github"
                   target="_blank" rel="external">
                    <span class="icon icon-github"></span>
                </a>
            
                <a href="/atom.xml" class="social rss"
                   target="_blank" rel="external">
                    <span class="icon icon-rss"></span>
                </a>
            
        
    </div>

    <div class="theme-by">Theme <span class="codename">Memory</span> designed by <a href="https://artifact.me/"
                                                                                    target="_blank">Art Chen</a>.
    </div>
    <div>&copy; <a href="/">氕氘氚</a></div>

</footer>


    <script>setLoadingBarProgress(80);</script>
    <div class="overlay"></div>
</div>

<div class="site-sidebar" id="site-sidebar">

    

    <div class="sidebar-switch clearfix "
         style="display: none">
        <a class="dark-btn active" data-toggle="toc">
            <span class="icon icon-list"></span>
            <span class="text">Index</span>
        </a>
        <a class="dark-btn" data-toggle="bio">
            <span class="icon icon-person"></span>
            <span class="text">Bio</span>
        </a>
    </div>

    <div class="site-toc "
         style="display: none">
        
            <div class="no-index">No Index</div>
        
    </div>

    <div class="site-bio show"
         style="display: block">

        <div class="about-me clearfix">
            <div class="avatar">
                <img src="/img/avatar.png"/>
            </div>
            <div class="info">
                <a class="name dark-btn" href="/about">
                    Szczecin
                </a>
            </div>
            <div class="info">
                <span class="item desc">
                    Open your eyes to see the light in life
                </span>
            </div>
        </div>

        <div class="menu section">
            <ul class="clearfix">
                
                    <li class="left">
                        <a href="/about"
                           onfocus="this.blur();"
                           class="nav-about dark-btn block">
                            简介
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/archives"
                           onfocus="this.blur();"
                           class="nav-archives dark-btn block">
                            归档
                        </a>
                    </li>
                
                    <li class="left">
                        <a href="/categories"
                           onfocus="this.blur();"
                           class="nav-categories dark-btn block">
                            分类
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/tags"
                           onfocus="this.blur();"
                           class="nav-tags dark-btn block">
                            TAGs
                        </a>
                    </li>
                
                    <li class="left">
                        <a href="/WriteUP"
                           onfocus="this.blur();"
                           class="nav-WriteUP dark-btn block">
                            WriteUP
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/EXP"
                           onfocus="this.blur();"
                           class="nav-EXP dark-btn block">
                            EXP
                        </a>
                    </li>
                
                    <li class="left">
                        <a href="/SRC"
                           onfocus="this.blur();"
                           class="nav-SRC dark-btn block">
                            SRC
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/Life"
                           onfocus="this.blur();"
                           class="nav-Life dark-btn block">
                            Life
                        </a>
                    </li>
                
            </ul>
        </div>

    </div>

    <div class="shortcuts">
        <a href="#header" class="top window-nav dark-btn" id="go-top">
            <span class="icon icon-chevron-thin-up"></span>
        </a>
        <a class="close dark-btn" id="sidebar-close">
            <span class="icon icon-close"></span>
        </a>
        <a href="#footer" class="top window-nav dark-btn" id="go-bottom">
            <span class="icon icon-chevron-thin-down"></span>
        </a>
    </div>

</div>





<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
  var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
  var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
  var ALGOLIA_API_KEY = "";
  var ALGOLIA_APP_ID = "";
  var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var SEARCH_SERVICE = "";
  var universalSearchConfig = {};
  if (SEARCH_SERVICE === 'google') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: GOOGLE_CUSTOM_SEARCH_API_KEY,
      engineId: GOOGLE_CUSTOM_SEARCH_ENGINE_ID,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'algolia') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: ALGOLIA_API_KEY,
      appId: ALGOLIA_APP_ID,
      indexName: ALGOLIA_INDEX_NAME,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'azure') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      serviceName: AZURE_SERVICE_NAME,
      indexName: AZURE_INDEX_NAME,
      apiKey: AZURE_QUERY_KEY,
      imagePath: "/img/"
    };
  }
</script>

<script src="/js/app.js"></script>


<script src="/js/search.js"></script>





<script>setLoadingBarProgress(100);</script>

</body>
</html>
